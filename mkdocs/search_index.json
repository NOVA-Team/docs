{
    "docs": [
        {
            "location": "/", 
            "text": "NOVA API\n\n\nWelcome to the documentation for the NOVA project. NOVA stands for \nN\neatly \nO\nrganized \nV\noxel \nA\nPI\n and is a project to create a total abstraction layer for creating addons to Voxel games such as \nMinecraft\n and \nTerasology\n.\n\n\nMore about NOVA\n\n\nNOVA provides modders with the ability to write mods for any game or mod loader that has a NOVA-compatible wrapper for it - which will at first include Minecraft Forge for 1.7.10 and 1.8, but developers are free to write wrappers for any other mod loader or minecraft-like game. The goal of NOVA is to provide modders both with an API that is easy to understand and learn while giving them confidence that their work can be used in many different environments without a painful update process.\n\n\nMods written using the NOVA library can be run on Forge, or can be run on top of any other mod loader or minecraft-like game for which a NOVA wrapper is available. This means that mods do not have to update when Minecraft updates. Also, it makes us relatively independent from Minecraft (or any of its mod loaders, for that matter), providing modders with the confidence that their mod will be usable even if major issues arise in Minecraft world.\n\n\nAside from the Modding API, we also hope to provide a peaceful modding environment that is open for everyone no matter their skills and experience.\n\n\nMinecraft modding is supposed to be fun \n for everyone!\n\n\nWhat\ns an abstraction layer?\n\n\nEvery version of Minecraft is built slightly differently and so is every Minecraft alternative. As a result, every time Minecraft updates, every mod written for it has to be updated to keep pace with the internal changes - there is no stable API. Even different mod loaders can add their own functionality and their own APIs to its users.\n\n\nEven though the code itself is different between each, the concepts are generally very similar. Every Minecraft-like game has a concept of blocks, items, entities, worlds, \n and instead of having modders depend on how exactly they are implemented in each game and version, we can instead expose classes and functions that expose the concepts shared by them using a stable and well-thought out API.\n\n\nBy focusing on this common API, we can make it easy to use. Additionally, by making use of Java 8 (which will be a requirement for running any NOVA wrapper) we can provide the latest language features to all modders - resulting in a cleaner API and cleaner code.\n\n\nWhat inspired you to create this?\n\n\nBesides the difficulties with porting Minecraft mods from one version to another, we have recently also seen the disappearance of a major modding API (Bukkit). When Microsoft bought Minecraft, we were not sure what their plans are, and so far, a clear statement has been absent. Modders, however, don\nt like to mod not being sure if the mod can be used in future.\n\n\nAlthough we cannot control the future of Minecraft, we can create a common API, abstract all necessary concepts with this abstraction layer, and have modders work on that. No matter what explodes in Minecraft world, we can always write a wrapper for a different modding library or any game that would contain the necessary features. The API is licensed as LGPLv3 and can be used by anyone without any legal worries, ever. And we as developers intend to communicate openly with the modding community to make sure that modders have the functionality they need.", 
            "title": "Home"
        }, 
        {
            "location": "/#nova-api", 
            "text": "Welcome to the documentation for the NOVA project. NOVA stands for  N eatly  O rganized  V oxel  A PI  and is a project to create a total abstraction layer for creating addons to Voxel games such as  Minecraft  and  Terasology .", 
            "title": "NOVA API"
        }, 
        {
            "location": "/#more-about-nova", 
            "text": "NOVA provides modders with the ability to write mods for any game or mod loader that has a NOVA-compatible wrapper for it - which will at first include Minecraft Forge for 1.7.10 and 1.8, but developers are free to write wrappers for any other mod loader or minecraft-like game. The goal of NOVA is to provide modders both with an API that is easy to understand and learn while giving them confidence that their work can be used in many different environments without a painful update process.  Mods written using the NOVA library can be run on Forge, or can be run on top of any other mod loader or minecraft-like game for which a NOVA wrapper is available. This means that mods do not have to update when Minecraft updates. Also, it makes us relatively independent from Minecraft (or any of its mod loaders, for that matter), providing modders with the confidence that their mod will be usable even if major issues arise in Minecraft world.  Aside from the Modding API, we also hope to provide a peaceful modding environment that is open for everyone no matter their skills and experience.  Minecraft modding is supposed to be fun   for everyone!", 
            "title": "More about NOVA"
        }, 
        {
            "location": "/#whats-an-abstraction-layer", 
            "text": "Every version of Minecraft is built slightly differently and so is every Minecraft alternative. As a result, every time Minecraft updates, every mod written for it has to be updated to keep pace with the internal changes - there is no stable API. Even different mod loaders can add their own functionality and their own APIs to its users.  Even though the code itself is different between each, the concepts are generally very similar. Every Minecraft-like game has a concept of blocks, items, entities, worlds,   and instead of having modders depend on how exactly they are implemented in each game and version, we can instead expose classes and functions that expose the concepts shared by them using a stable and well-thought out API.  By focusing on this common API, we can make it easy to use. Additionally, by making use of Java 8 (which will be a requirement for running any NOVA wrapper) we can provide the latest language features to all modders - resulting in a cleaner API and cleaner code.", 
            "title": "What's an abstraction layer?"
        }, 
        {
            "location": "/#what-inspired-you-to-create-this", 
            "text": "Besides the difficulties with porting Minecraft mods from one version to another, we have recently also seen the disappearance of a major modding API (Bukkit). When Microsoft bought Minecraft, we were not sure what their plans are, and so far, a clear statement has been absent. Modders, however, don t like to mod not being sure if the mod can be used in future.  Although we cannot control the future of Minecraft, we can create a common API, abstract all necessary concepts with this abstraction layer, and have modders work on that. No matter what explodes in Minecraft world, we can always write a wrapper for a different modding library or any game that would contain the necessary features. The API is licensed as LGPLv3 and can be used by anyone without any legal worries, ever. And we as developers intend to communicate openly with the modding community to make sure that modders have the functionality they need.", 
            "title": "What inspired you to create this?"
        }, 
        {
            "location": "/Mod Development/Getting Started/", 
            "text": "Workspace Setup\n\n\nWorkspace setup is done with the NOVA Gradle plugin, make sure you follow the setup docs \nhere\n\n\nMod Loading\n\n\nAll mods have a main class that implements \nLoadable\n and is annotated with \n@NovaMod\n. The \n@NovaMod\n annotation tells NOVA that this is a mod class that needs to be loaded. Any class which implements \nLoadable\n has three methods, \npreInit()\n, \ninit()\n, and \npostInit()\n. These methods are automatically called during the appropriated loading phases. Most of the content in NOVA must be registered during the preInit phase.\n\n\n@NovaMod(id = NovaBlock.id, name = \nNova Example Block\n, version = \n0.0.1\n, novaVersion = \n0.0.1\n)\npublic class NovaBlock implements Loadable {\n\n    public static final String id = \nnovablock\n;\n\n    public static BlockFactory blockStateful;\n    public static BlockFactory blockStateless;\n\n    public final BlockManager blockManager;\n\n    public NovaBlock(BlockManager blockManager) {\n        this.blockManager = blockManager;\n    }\n\n    @Override\n    public void preInit() {\n        blockStateful = blockManager.register(BlockStateful.class);\n        blockStateless = blockManager.register(BlockStateless.class);\n    }\n}\n\n\n\n\nDependency Injection\n\n\nAll NOVA mods use dependency injection. Using dependency injection NOVA mods can automatically accept only the managers that they need. In the example above, the mod constructor only accepts a \nBlockManager\n so when the mod is constructed it will only be passed a \nBlockManager\n. If we were to change the constructor so it accepts a \nBlockManager\n and an \nItemManager\n, the dependency injection system will pass it a \nBlockManager\n and an \nItemManager\n when the mod is constructed. This allows the mod constructor to only accept whatever it needs and NOVA will determine what to pass it at load time.", 
            "title": "Getting started"
        }, 
        {
            "location": "/Mod Development/Getting Started/#workspace-setup", 
            "text": "Workspace setup is done with the NOVA Gradle plugin, make sure you follow the setup docs  here", 
            "title": "Workspace Setup"
        }, 
        {
            "location": "/Mod Development/Getting Started/#mod-loading", 
            "text": "All mods have a main class that implements  Loadable  and is annotated with  @NovaMod . The  @NovaMod  annotation tells NOVA that this is a mod class that needs to be loaded. Any class which implements  Loadable  has three methods,  preInit() ,  init() , and  postInit() . These methods are automatically called during the appropriated loading phases. Most of the content in NOVA must be registered during the preInit phase.  @NovaMod(id = NovaBlock.id, name =  Nova Example Block , version =  0.0.1 , novaVersion =  0.0.1 )\npublic class NovaBlock implements Loadable {\n\n    public static final String id =  novablock ;\n\n    public static BlockFactory blockStateful;\n    public static BlockFactory blockStateless;\n\n    public final BlockManager blockManager;\n\n    public NovaBlock(BlockManager blockManager) {\n        this.blockManager = blockManager;\n    }\n\n    @Override\n    public void preInit() {\n        blockStateful = blockManager.register(BlockStateful.class);\n        blockStateless = blockManager.register(BlockStateless.class);\n    }\n}", 
            "title": "Mod Loading"
        }, 
        {
            "location": "/Mod Development/Getting Started/#dependency-injection", 
            "text": "All NOVA mods use dependency injection. Using dependency injection NOVA mods can automatically accept only the managers that they need. In the example above, the mod constructor only accepts a  BlockManager  so when the mod is constructed it will only be passed a  BlockManager . If we were to change the constructor so it accepts a  BlockManager  and an  ItemManager , the dependency injection system will pass it a  BlockManager  and an  ItemManager  when the mod is constructed. This allows the mod constructor to only accept whatever it needs and NOVA will determine what to pass it at load time.", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/Mod Development/NOVA Gradle/", 
            "text": "If you feel like tl;dring this artifacle, skip to \n#getting-started\n.\nI however do not reccomend this because knowing your build system will save you trouble later.\nIf you know gradle well, you know what to skip already.\n\n\n\n\nNOVA Gradle is the Gradle plugin which allows you to run NOVA mods on wrappers easily during testing.\nVanilla Gradle can compile and produce (non-wrapper) NOVA mods and plugins easilly but it lacks an easy way to test and debug these mods ingame.\nNOVA Gradle handles IDE setup and game setup for you so you don\nt have to. Let\ns get started!\n\n\nGradle\n\n\nGradle is a tool some of you will have used when compiling MinecraftForge mods.\nThe Gradle \nDSL\n which Gradle uses to define configuration is written in Groovy, so you can use the awesome Groovy programming language to script your build.\nDespite this, Gradle is convention based and declaritive. Compiling a NOVA provect is as simple as:\n\n\nplugins {\n    id \njava\n\n}\n\nrepositories {\n    jcenter()\n    maven { url \nhttp://maven.novaapi.net/\n }\n}\n\ndependencies {\n    compile \nnova.core:NOVA-Core:0.1.0-SNAPSHOT:api\n\n}\n\n\n\n\nThis short snippet simply defines that you are using the \njava\n Gradle plugin (you want to compile java),\nthat you want to resolve dependencies from the jcenter and NOVA repositories and\nthat your project\ns compilation depends on the NOVA api, version \n0.1.0-SNAPSHOT\n.\n\n\nThe \njava\n plugin defines several important tasks just as \ncompileJava\n \njar\n and \nbuild\n.\nBut wait you say, how do you run Gradle? Do I have to install yet \nanother\n thing\n What a pain!\n\n\nThe Gradle Wrapper\n\n\nThe Gradle wrapper solves this problem by providing scripts that you place in your project directory which downloads Gradle automatically for you then invokes the downloaded Gradle version.\nThe Gradle wrapper is included in the NOVA template project.\n\n\nNOVA Gradle\n\n\nThe previous snippet allows you to build a jar which can be loaded by NOVA wrappers, but there is no easy way to debug and run this mod every time you make a change. This is where NOVA Gradle comes in.\n\n\nGetting started\n\n\nTo explain to you how to use NOVA Gradle and how to set up your mod development workspace, we will use the NOVA template project from Github.\nThe NOVA Template project can be downloaded from \nhere\n and then unzipped to the place where you want to develop your mod.\n\n\nYou will see the following files in the template:\n\n\n\n\nIf you are tl;dring, skip everything that isn\nt marked \nCustomise this\n until \nSetting up\n\n\n\n\nbuild.gradle\n\n\nThis file is the file which describes the Gradle build process.\n\n\nHere is an annotated version of the default \nbuild.gradle\n, \nplease use the file from NOVA-Template instead of copying this\n \ncough\n calclavia \ncough\n.\n\n\nplugins {\n    id \njava\n //This is a java project, scala and groovy plugins also exist\n    id \nnova.gradle\n version \n0.2.6\n //Use the NOVA Gradle plugin version 0.2.6\n}\n\ndependencies { //Dependencies of this project\n    compile nova(\n0.1.0-SNAPSHOT\n) //Depend on NOVA for compiling\n}\n\nnova { //This block is used for configuring the NOVA Gradle plugin\n    wrappers { //Configures wrapper profiles\n        /**\n         * This profile is called \n17\n, you can skip the quotes if it's not numbers.\n         * This profile for example will generate the \nrun17Client\n gradle task and create an IDEA\n         * config of the same name.\n         * The name can be changed to your liking.\n         */\n        \n17\n {\n            //The maven identifier of the wrapper this wrapper profile will use.\n            wrapper \nnova.core:NOVA-Core-Wrapper-MC1.7:0.1.0-SNAPSHOT\n\n        }\n\n        //Wrapper profile for MC 1.8\n        \n18\n {\n            wrapper \nnova.core:NOVA-Core-Wrapper-MC1.8:0.1.0-SNAPSHOT\n\n        }\n    }\n}\n\n\n\n\ngradle.properties\n (Customise this)\n\n\nThis file stores properties which are made available to the build process, such as version and maven group.\n\n\nThe Maven group defines a unique identifier for your project, and should be the same as your Java package.\nThe convention is to use your domain name backwards as the start of your package, for example \nnet.novaapi.template\n if you own the domain \nnovaapi.net\n.\nIf you don\nt have a domain, and you are open-sourcing the mod, the common practise is to use \ncom.github.githubusername.githubprojectname\n.\nIf you aren\nt open sourcing or publishing the mod API, nobody really cares what package name you use\n\n\nsettings.gradle\n (Customise this)\n\n\nThis file is used for setting the name of the project (\nrootProject.name = \"project name\"\n) and for multi-project builds.\nMulti-project builds are a complex topic that I will not cover in this introduction.\n\n\ngradlew\n and \ngradlew.bat\n\n\nThese scripts are the gradle wrapper scripts mentined before for running gradle.\nUse simply \ngradlew\n on windows and \n./gradlew\n on linux.\n\n\n.gitignore\n\n\nThis file configures files and folders ignored if you use the \ngit\n revision control system.\nWe\nve included sensible defaults for you, so you don\nt go publishing all the wrong things.\nRemember, if you publish the wrong things you will make RX14 mildly depressed if he happens across your project.\n\n\nThe \ngradle/\n folder\n\n\nThis is just files related to the gradle wrapper, you may occationally need to update the wrapper version in this folder, but unless instructed just ignore it.\n\n\nSetting up\n\n\nAfter customising the files in your template project, pop up a terminal and \ncd\n to the project directory.\n\n\nIdea\n\n\nWhen you are in your project directory use \n./gradlew idea\n on linux or \ngradlew idea\n on windows to generate IDEA project files.\n\n\nAfter it has generated these files, open the \n.ipr\n IDEA Project file in IDEA.\nYou should see some run configurations added corresponding to the wrapper profiles in the \nbuild.gradle\n.\n\n\nEclipse\n\n\nIf you are using eclipse instead of IDEA, you will have to run \ngradle eclipse\n and import the generated project into a new or existing workspace. No run configurations will be gerated, so you will have to use the \ngradle plugin for eclipse\n to run the wrapper gradle tasks (e.g. \nrun17Client\n).\n\n\nIDEA Bugs (on windows)\n\n\nThe supplied javaHome seems to be invalid. I cannot find the java executable. Tried location: C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA 14.1.4\\jre\\bin\\java.exe`\n\n\n\n\nYou will most likely experience the above (or similar) error when trying to run or debug the client.\nThis is a bug in IDEA, and the workaround is to use 64-bit IDEA.\nTo do this, edit your IntelliJ start menu shortcut and change the path of what it is running from \n\"C:\\Install Path\\bin\\idea.exe\"\n to \n\"C:\\Install Path\\bin\\idea64.exe\"\n like this:\n\n\n\n\nIf the problem persists after this please ask in IRC.", 
            "title": "NOVA Gradle"
        }, 
        {
            "location": "/Mod Development/NOVA Gradle/#gradle", 
            "text": "Gradle is a tool some of you will have used when compiling MinecraftForge mods.\nThe Gradle  DSL  which Gradle uses to define configuration is written in Groovy, so you can use the awesome Groovy programming language to script your build.\nDespite this, Gradle is convention based and declaritive. Compiling a NOVA provect is as simple as:  plugins {\n    id  java \n}\n\nrepositories {\n    jcenter()\n    maven { url  http://maven.novaapi.net/  }\n}\n\ndependencies {\n    compile  nova.core:NOVA-Core:0.1.0-SNAPSHOT:api \n}  This short snippet simply defines that you are using the  java  Gradle plugin (you want to compile java),\nthat you want to resolve dependencies from the jcenter and NOVA repositories and\nthat your project s compilation depends on the NOVA api, version  0.1.0-SNAPSHOT .  The  java  plugin defines several important tasks just as  compileJava   jar  and  build .\nBut wait you say, how do you run Gradle? Do I have to install yet  another  thing  What a pain!  The Gradle Wrapper  The Gradle wrapper solves this problem by providing scripts that you place in your project directory which downloads Gradle automatically for you then invokes the downloaded Gradle version.\nThe Gradle wrapper is included in the NOVA template project.", 
            "title": "Gradle"
        }, 
        {
            "location": "/Mod Development/NOVA Gradle/#nova-gradle", 
            "text": "The previous snippet allows you to build a jar which can be loaded by NOVA wrappers, but there is no easy way to debug and run this mod every time you make a change. This is where NOVA Gradle comes in.  Getting started  To explain to you how to use NOVA Gradle and how to set up your mod development workspace, we will use the NOVA template project from Github.\nThe NOVA Template project can be downloaded from  here  and then unzipped to the place where you want to develop your mod.  You will see the following files in the template:   If you are tl;dring, skip everything that isn t marked  Customise this  until  Setting up   build.gradle  This file is the file which describes the Gradle build process.  Here is an annotated version of the default  build.gradle ,  please use the file from NOVA-Template instead of copying this   cough  calclavia  cough .  plugins {\n    id  java  //This is a java project, scala and groovy plugins also exist\n    id  nova.gradle  version  0.2.6  //Use the NOVA Gradle plugin version 0.2.6\n}\n\ndependencies { //Dependencies of this project\n    compile nova( 0.1.0-SNAPSHOT ) //Depend on NOVA for compiling\n}\n\nnova { //This block is used for configuring the NOVA Gradle plugin\n    wrappers { //Configures wrapper profiles\n        /**\n         * This profile is called  17 , you can skip the quotes if it's not numbers.\n         * This profile for example will generate the  run17Client  gradle task and create an IDEA\n         * config of the same name.\n         * The name can be changed to your liking.\n         */\n         17  {\n            //The maven identifier of the wrapper this wrapper profile will use.\n            wrapper  nova.core:NOVA-Core-Wrapper-MC1.7:0.1.0-SNAPSHOT \n        }\n\n        //Wrapper profile for MC 1.8\n         18  {\n            wrapper  nova.core:NOVA-Core-Wrapper-MC1.8:0.1.0-SNAPSHOT \n        }\n    }\n}  gradle.properties  (Customise this)  This file stores properties which are made available to the build process, such as version and maven group.  The Maven group defines a unique identifier for your project, and should be the same as your Java package.\nThe convention is to use your domain name backwards as the start of your package, for example  net.novaapi.template  if you own the domain  novaapi.net .\nIf you don t have a domain, and you are open-sourcing the mod, the common practise is to use  com.github.githubusername.githubprojectname .\nIf you aren t open sourcing or publishing the mod API, nobody really cares what package name you use  settings.gradle  (Customise this)  This file is used for setting the name of the project ( rootProject.name = \"project name\" ) and for multi-project builds.\nMulti-project builds are a complex topic that I will not cover in this introduction.  gradlew  and  gradlew.bat  These scripts are the gradle wrapper scripts mentined before for running gradle.\nUse simply  gradlew  on windows and  ./gradlew  on linux.  .gitignore  This file configures files and folders ignored if you use the  git  revision control system.\nWe ve included sensible defaults for you, so you don t go publishing all the wrong things.\nRemember, if you publish the wrong things you will make RX14 mildly depressed if he happens across your project.  The  gradle/  folder  This is just files related to the gradle wrapper, you may occationally need to update the wrapper version in this folder, but unless instructed just ignore it.  Setting up  After customising the files in your template project, pop up a terminal and  cd  to the project directory.  Idea  When you are in your project directory use  ./gradlew idea  on linux or  gradlew idea  on windows to generate IDEA project files.  After it has generated these files, open the  .ipr  IDEA Project file in IDEA.\nYou should see some run configurations added corresponding to the wrapper profiles in the  build.gradle .  Eclipse  If you are using eclipse instead of IDEA, you will have to run  gradle eclipse  and import the generated project into a new or existing workspace. No run configurations will be gerated, so you will have to use the  gradle plugin for eclipse  to run the wrapper gradle tasks (e.g.  run17Client ).  IDEA Bugs (on windows)  The supplied javaHome seems to be invalid. I cannot find the java executable. Tried location: C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA 14.1.4\\jre\\bin\\java.exe`  You will most likely experience the above (or similar) error when trying to run or debug the client.\nThis is a bug in IDEA, and the workaround is to use 64-bit IDEA.\nTo do this, edit your IntelliJ start menu shortcut and change the path of what it is running from  \"C:\\Install Path\\bin\\idea.exe\"  to  \"C:\\Install Path\\bin\\idea64.exe\"  like this:   If the problem persists after this please ask in IRC.", 
            "title": "NOVA Gradle"
        }, 
        {
            "location": "/Mod Development/Blocks/", 
            "text": "Blocks are the basic ingredient of any voxel game, and their existence is essential. To create a block, you must register it with the BlockManager in your mod\ns preInit() stage.\n\n\nBlockFactory blockStateless = blockManager.register(BlockStateless.class);\n\n\n\n\nThe code above registers a block class called \nBlockStateless\n. \nBlockStateless\n extends \nBlock\n. The following is \nBlockStateless\ns code.\n\n\npublic class BlockStateless extends Block implements Syncable {\n\n    public BlockStateless() {\n        add(new StaticBlockRenderer(this)).setTexture(NovaBlock.steelTexture);\n\n        add(new Collider());\n\n        add(new ItemRenderer(this));\n\n        add(new Category(\nbuildingBlocks\n));\n        events.on(RightClickEvent.class).bind(this::onRightClick);\n    }\n\n    public void onRightClick(RightClickEvent evt) {\n        System.out.println(\nSending Packet: 1234\n);\n        NovaBlock.networkManager.sync(this);\n    }\n\n    @Override\n    public String getID() {\n        return \nsimple\n;\n    }\n}\n\n\n\n\nSee \nhere\n for the most up-to-date example.\n\n\nComponents\n\n\nThere are some components you will probably always want to implement in your blocks. However, none of them are required and can be left out or replaced with your own versions of it.\n\n\nCollider\n\n\nThis component determines a few properties of your block, namely if it is a cube, opaque, what its bounding and selection boxes are. It also has an event bus for collision events. The default collider is a 1x1x1 cube.\n\n\nCategory\n\n\nThis is the category (equivalent to a creative tab in Minecraft) that this block belongs to.\n\n\nItemRenderer\n\n\nThis handles the rendering of the block in your inventory and hand.\n\n\nBlockRenderer\n\n\nThis is responsible for rendering the block in the world. In the example above, \nStaticBlockRenderer\n is used but there are a few others you can use as well. \n\n\nSpecial Components\n\n\nNOVA is meant to be modular and allows you to make your own components to add but it\ns also \nBatteries included.\n Here are some components that NOVA provides you might find useful.\n\n\nOrientation\n\n\nOrientation allows your block to be rotated and face towards a specific side. Using this, your block can have a front, back and specific sides.\n\n\nIf you just add this component to the components not much will happen. The best thing to do is save this in a variable and annotate it with the \n@Sync\n and \n@Store\n annotations. The \n@Sync\n will sync between client and server (for that you should also have the block sync when it is placed down, see networking on how to do that)\nThe \n@Store\n will save and load the orientation so the data is not lost when the world is reloaded\n\n\nSpecial Interfaces\n\n\nSyncable\n\n\nYou may have noticed that BlockStateless implements Syncable. This interface allows the block to handle packets easily. By implementing Syncable, the block can synchronize between server and client. You can override the default methods \nread(Packet packet)\n and \nwrite(Packet packet)\n as shown in the example to read and write custom packets upon synchronization. Any variable annotated by \n@Sync\n will be synced between server and client, as long as you either leave the default methods alone or call \nSyncable.super.read(packet);\n and \nSyncable.super.write(packet);\n from your read and write methods respectively.\n\n\nStateful\n\n\nBy default, blocks will be stateless. This means that blocks will be unable to retain their variables and state. Stateless blocks are more efficient and are appropriate for blocks that are abundant and have no internal logic (e.g: Decoration blocks, ores and resources). However, more complex blocks will need to implement \nStateful\n interface, which allows it to store its state in the world.\n\n\nStorable\n\n\nStorable allows a block to store its variables when a game saves. By implementing \nStorable\n, the block will be able to use the \n@Store\n annotation on variables you want to store. Note that not all variables can be properly stored via \n@Store\n, so you may need to override \nsave\n and \nload\n to store the variables in whatever way fits them. If you want to use both the annotations and read/write your own custom data, call \nStorable.super.read(packet);\n and \nStorable.super.write(packet);\n in your overridden read/write methods.\n\n\nRendering\n\n\nTo render your block you have several options:\n\n\n\n\nUse the \nStaticBlockRenderer\n\n\nUse any of the other built-in NOVA renderers\n\n\nCreate your own block renderer\n\n\n\n\nStaticBlockRenderer\n\n\nThis is used for rendering simple blocks with static textures that only update when the block does.\n\n\nRotatedRenderer\n\n\nThis is for use in combination with the \nOrientation\n component, it rotates the rendering of the block to match the rotation stored in the \nOrientation\n object. If you use this you should also use a function to give multiple textures as there is no point in rotated rendering if the block has the same texture on all sides.\n\n\nAdvanced Example\n\n\nThis is an example of a block that combines most of the things listed above, it has a collider, is rotatable (and rendered as such) and print it\ns orientation to the console when right-clicked.\n\n\npublic class BasicDuster extends Block implements Stateful, Storable, Syncable {\n\n    /*\n     * Orientation component.\n     * \nhookBasedOnHitSide\n sets up events so the orientation is set based upon, well, hit side.\n     * This needs to be synced to client, and stored, so @Sync and @Store are used.\n     */\n    @Sync\n    @Store\n    private Component orientation = new Orientation(this).hookBasedOnHitSide();\n\n    /**\n     * Constructor for this block. Adds components, and binds events.\n     */\n    public BasicDuster() {\n        add(new Collider()); // Collider (so the player doesn't walk through the block.)\n        add(orientation); // Orientation (see above)\n        add(new RotatedRenderer(this).setTexture(this::getTexture)); // Version of StaticBlockRenderer that honors Orientation.\n        add(new ItemRenderer(this)); // Make the item render like the block.\n        add(new Category(\nbuildingBlocks\n)); // Put this in the \nBuilding Blocks\n Creative category (in MC, anyway)\n        events.on(RightClickEvent.class).bind(this::click); // Make sure \nclick\n is called when a player right-clicks this block\n        orientation.events.on(Block.PlaceEvent.class).bind((e) -\n YourMod.networkManager.sync(this)); // Make sure we sync when the orientation is initially set\n    }\n\n    /**\n     * Gets the texture for a given side.\n     * Note that this is referred to by the code above(see \nadd(new RotatedRenderer\n)),\n     * and does not have to be specifically called \ngetTexture\n. It's just convention.\n     * @param dir The direction the side is on.\n     * @return A texture. Or empty. (TODO: What does empty do here?)\n     */\n    public Optional\nTexture\n getTexture(Direction dir) {\n        Optional\nTexture\n texture = Optional.empty();\n        switch (dir) {\n            case NORTH: texture = Optional.of(Textures.dusterFront); break;\n            case EAST:\n            case WEST: texture = Optional.of(Textures.dusterSides); break;\n            case SOUTH: texture = Optional.of(Textures.dusterBack); break;\n            case UP: texture = Optional.of(Textures.dusterTop); break;\n            case DOWN: texture = Optional.of(Textures.dusterBottom); break;\n        }\n        return texture;\n    }\n\n    /**\n     * Implements Syncable.read.\n     * This is called when a sync packet is received, to update the block's state.\n     * @param packet The sync packet.\n     */\n    @Override\n    public void read(Packet packet) {\n        Syncable.super.read(packet); // Make sure @Sync annotations are processed.\n        world().markStaticRender(position()); // Mark for static render.\n    }\n\n    /**\n     * This is referenced above(see \nevents.on(RightClickEvent.class)\n),\n     * and handles a right click on this block.\n     * @param event Details of the right-click event.\n     */\n    public void click(RightClickEvent event) {\n        if (Game.network().isServer()) {\n            // If we're on the server, then write the orientation to the console for debugging.\n            System.out.println(get(Orientation.class).orientation());\n        }\n    }\n\n    /**\n     * Gets the block ID.\n     * @return The block's ID.\n     */\n    @Override\n    public String getID() {\n        return \nbasicDuster\n;\n    }\n}", 
            "title": "Blocks"
        }, 
        {
            "location": "/Mod Development/Blocks/#components", 
            "text": "There are some components you will probably always want to implement in your blocks. However, none of them are required and can be left out or replaced with your own versions of it.  Collider  This component determines a few properties of your block, namely if it is a cube, opaque, what its bounding and selection boxes are. It also has an event bus for collision events. The default collider is a 1x1x1 cube.  Category  This is the category (equivalent to a creative tab in Minecraft) that this block belongs to.  ItemRenderer  This handles the rendering of the block in your inventory and hand.  BlockRenderer  This is responsible for rendering the block in the world. In the example above,  StaticBlockRenderer  is used but there are a few others you can use as well.", 
            "title": "Components"
        }, 
        {
            "location": "/Mod Development/Blocks/#special-components", 
            "text": "NOVA is meant to be modular and allows you to make your own components to add but it s also  Batteries included.  Here are some components that NOVA provides you might find useful.  Orientation  Orientation allows your block to be rotated and face towards a specific side. Using this, your block can have a front, back and specific sides.  If you just add this component to the components not much will happen. The best thing to do is save this in a variable and annotate it with the  @Sync  and  @Store  annotations. The  @Sync  will sync between client and server (for that you should also have the block sync when it is placed down, see networking on how to do that)\nThe  @Store  will save and load the orientation so the data is not lost when the world is reloaded", 
            "title": "Special Components"
        }, 
        {
            "location": "/Mod Development/Blocks/#special-interfaces", 
            "text": "Syncable  You may have noticed that BlockStateless implements Syncable. This interface allows the block to handle packets easily. By implementing Syncable, the block can synchronize between server and client. You can override the default methods  read(Packet packet)  and  write(Packet packet)  as shown in the example to read and write custom packets upon synchronization. Any variable annotated by  @Sync  will be synced between server and client, as long as you either leave the default methods alone or call  Syncable.super.read(packet);  and  Syncable.super.write(packet);  from your read and write methods respectively.  Stateful  By default, blocks will be stateless. This means that blocks will be unable to retain their variables and state. Stateless blocks are more efficient and are appropriate for blocks that are abundant and have no internal logic (e.g: Decoration blocks, ores and resources). However, more complex blocks will need to implement  Stateful  interface, which allows it to store its state in the world.  Storable  Storable allows a block to store its variables when a game saves. By implementing  Storable , the block will be able to use the  @Store  annotation on variables you want to store. Note that not all variables can be properly stored via  @Store , so you may need to override  save  and  load  to store the variables in whatever way fits them. If you want to use both the annotations and read/write your own custom data, call  Storable.super.read(packet);  and  Storable.super.write(packet);  in your overridden read/write methods.", 
            "title": "Special Interfaces"
        }, 
        {
            "location": "/Mod Development/Blocks/#rendering", 
            "text": "To render your block you have several options:   Use the  StaticBlockRenderer  Use any of the other built-in NOVA renderers  Create your own block renderer   StaticBlockRenderer  This is used for rendering simple blocks with static textures that only update when the block does.  RotatedRenderer  This is for use in combination with the  Orientation  component, it rotates the rendering of the block to match the rotation stored in the  Orientation  object. If you use this you should also use a function to give multiple textures as there is no point in rotated rendering if the block has the same texture on all sides.", 
            "title": "Rendering"
        }, 
        {
            "location": "/Mod Development/Blocks/#advanced-example", 
            "text": "This is an example of a block that combines most of the things listed above, it has a collider, is rotatable (and rendered as such) and print it s orientation to the console when right-clicked.  public class BasicDuster extends Block implements Stateful, Storable, Syncable {\n\n    /*\n     * Orientation component.\n     *  hookBasedOnHitSide  sets up events so the orientation is set based upon, well, hit side.\n     * This needs to be synced to client, and stored, so @Sync and @Store are used.\n     */\n    @Sync\n    @Store\n    private Component orientation = new Orientation(this).hookBasedOnHitSide();\n\n    /**\n     * Constructor for this block. Adds components, and binds events.\n     */\n    public BasicDuster() {\n        add(new Collider()); // Collider (so the player doesn't walk through the block.)\n        add(orientation); // Orientation (see above)\n        add(new RotatedRenderer(this).setTexture(this::getTexture)); // Version of StaticBlockRenderer that honors Orientation.\n        add(new ItemRenderer(this)); // Make the item render like the block.\n        add(new Category( buildingBlocks )); // Put this in the  Building Blocks  Creative category (in MC, anyway)\n        events.on(RightClickEvent.class).bind(this::click); // Make sure  click  is called when a player right-clicks this block\n        orientation.events.on(Block.PlaceEvent.class).bind((e) -  YourMod.networkManager.sync(this)); // Make sure we sync when the orientation is initially set\n    }\n\n    /**\n     * Gets the texture for a given side.\n     * Note that this is referred to by the code above(see  add(new RotatedRenderer )),\n     * and does not have to be specifically called  getTexture . It's just convention.\n     * @param dir The direction the side is on.\n     * @return A texture. Or empty. (TODO: What does empty do here?)\n     */\n    public Optional Texture  getTexture(Direction dir) {\n        Optional Texture  texture = Optional.empty();\n        switch (dir) {\n            case NORTH: texture = Optional.of(Textures.dusterFront); break;\n            case EAST:\n            case WEST: texture = Optional.of(Textures.dusterSides); break;\n            case SOUTH: texture = Optional.of(Textures.dusterBack); break;\n            case UP: texture = Optional.of(Textures.dusterTop); break;\n            case DOWN: texture = Optional.of(Textures.dusterBottom); break;\n        }\n        return texture;\n    }\n\n    /**\n     * Implements Syncable.read.\n     * This is called when a sync packet is received, to update the block's state.\n     * @param packet The sync packet.\n     */\n    @Override\n    public void read(Packet packet) {\n        Syncable.super.read(packet); // Make sure @Sync annotations are processed.\n        world().markStaticRender(position()); // Mark for static render.\n    }\n\n    /**\n     * This is referenced above(see  events.on(RightClickEvent.class) ),\n     * and handles a right click on this block.\n     * @param event Details of the right-click event.\n     */\n    public void click(RightClickEvent event) {\n        if (Game.network().isServer()) {\n            // If we're on the server, then write the orientation to the console for debugging.\n            System.out.println(get(Orientation.class).orientation());\n        }\n    }\n\n    /**\n     * Gets the block ID.\n     * @return The block's ID.\n     */\n    @Override\n    public String getID() {\n        return  basicDuster ;\n    }\n}", 
            "title": "Advanced Example"
        }, 
        {
            "location": "/Mod Development/Events/", 
            "text": "Event Handling\n\n\nOne of NOVA\ns core features is the large variety of events you can use. With Java 8, you can bind functions to events like so:\n\n\nevents.on(RightClickEvent.class).bind(this::onRightClick);\n\n\n\n\nTo bind a function that function needs to have the class you bind with as parm, for example:\n\n\npublic void onRightClick(RightClickEvent evt) {\n    System.out.println(\nSending Packet: 1234\n);\n    NovaBlock.networkManager.sync(this);\n}\n\n\n\n\nAvailable Events\n\n\nBlock\n Events\n\n\n\n\nNeighborChangeEvent\n\n\nPlaceEvent\n\n\nRemoveEvent\n\n\nRightClickEvent\n\n\nLeftClickEvent\n\n\nDropEvent\n\n\n\n\nItem\n Events\n\n\n\n\nTooltipEvent\n\n\nUseEvent\n\n\nRightClickEvent", 
            "title": "Events"
        }, 
        {
            "location": "/Mod Development/Events/#event-handling", 
            "text": "One of NOVA s core features is the large variety of events you can use. With Java 8, you can bind functions to events like so:  events.on(RightClickEvent.class).bind(this::onRightClick);  To bind a function that function needs to have the class you bind with as parm, for example:  public void onRightClick(RightClickEvent evt) {\n    System.out.println( Sending Packet: 1234 );\n    NovaBlock.networkManager.sync(this);\n}", 
            "title": "Event Handling"
        }, 
        {
            "location": "/Mod Development/Events/#available-events", 
            "text": "Block  Events   NeighborChangeEvent  PlaceEvent  RemoveEvent  RightClickEvent  LeftClickEvent  DropEvent   Item  Events   TooltipEvent  UseEvent  RightClickEvent", 
            "title": "Available Events"
        }, 
        {
            "location": "/NOVA Development/Development Workspace Setup/", 
            "text": "It is suggested to keep NOVA development in it\ns own folder, an example file structure would be something like this:\n\n\nNOVA\n|-- core\n|-- gui\n...\n\n\n\n\nImportant:\n\nNOVA uses Gradle for building. To help with using Gradle, NOVA uses the Gradle wrapper system so that the developer does not have to install Gradle. For that reason, if you do not have Gradle installed, instead of typing \ngradle\n type:\n\n\n\n\ngradlew\n on Windows,\n\n\n./gradlew\n on Linux or OS X.\n\n\n\n\nNOVA Core\n\n\nSetting up a NOVA Core development workspace is easy, here\ns how you do it:\n\n\n\n\nClone \nNOVA-Core\n.\n\n\nRun \ngradle setupDecompWorkspace idea\n if you use IntelliJ IDEA or \ngradle setupDecompWorkspace eclipse\n if you use Eclipse.\n\n\nAppend \n-Dfml.coreMods.load=nova.core.wrapper.mc18.NovaMinecraftCore\n for MC v1.8 or \n-Dfml.coreMods.load=nova.core.wrapper.mc17.NovaMinecraftCore\n for MC v1.7 to the VM arguments of your run configurations.", 
            "title": "Development Workspace Setup"
        }, 
        {
            "location": "/NOVA Development/Development Workspace Setup/#nova-core", 
            "text": "Setting up a NOVA Core development workspace is easy, here s how you do it:   Clone  NOVA-Core .  Run  gradle setupDecompWorkspace idea  if you use IntelliJ IDEA or  gradle setupDecompWorkspace eclipse  if you use Eclipse.  Append  -Dfml.coreMods.load=nova.core.wrapper.mc18.NovaMinecraftCore  for MC v1.8 or  -Dfml.coreMods.load=nova.core.wrapper.mc17.NovaMinecraftCore  for MC v1.7 to the VM arguments of your run configurations.", 
            "title": "NOVA Core"
        }, 
        {
            "location": "/NOVA Development/Formatting/", 
            "text": "IDEA\n\n\n\n\nOpen your \nIDEA\n project.\n\n\nGo to \nFile -\n Import Settings...\n.\n\n\nWhen prompted, select \nintelliJ-formatter.jar\n in the \nNOVA-Core/guidelines/\n and click \nOK\n.\n\n\nNow there might be a window showing you which settings are going to be changed. Make sure all of the boxes are checked and click \nOK\n.\n\n\nRestart \nIDEA\n if asked to.\n\n\nGo to \nFile -\n Settings... -\n Editor -\n Code Style\n, select \nNOVAFormat\n as the Scheme and click \nApply\n.\n\n\nStaying in the Settings, go to \nEditor -\n Inspections\n, select \nNOVAInspect\n as the Profile, click \nApply\n and then \nOK\n.\n\n\n\n\nEclipse\n\n\n\n\nOpen your \nEclipse\n project.\n\n\nOpen the preferences window.\n\n\nOpen the \nJava -\n Code Style -\n Formatter\n pane.\n\n\nClick \nImport...\n and when prompted, select \neclipse-formatter.xml\n in the \nNOVA-Core/guidelines/\n folder.", 
            "title": "Formatting"
        }, 
        {
            "location": "/NOVA Development/Formatting/#idea", 
            "text": "Open your  IDEA  project.  Go to  File -  Import Settings... .  When prompted, select  intelliJ-formatter.jar  in the  NOVA-Core/guidelines/  and click  OK .  Now there might be a window showing you which settings are going to be changed. Make sure all of the boxes are checked and click  OK .  Restart  IDEA  if asked to.  Go to  File -  Settings... -  Editor -  Code Style , select  NOVAFormat  as the Scheme and click  Apply .  Staying in the Settings, go to  Editor -  Inspections , select  NOVAInspect  as the Profile, click  Apply  and then  OK .", 
            "title": "IDEA"
        }, 
        {
            "location": "/NOVA Development/Formatting/#eclipse", 
            "text": "Open your  Eclipse  project.  Open the preferences window.  Open the  Java -  Code Style -  Formatter  pane.  Click  Import...  and when prompted, select  eclipse-formatter.xml  in the  NOVA-Core/guidelines/  folder.", 
            "title": "Eclipse"
        }, 
        {
            "location": "/NOVA Development/JavaDoc Style/", 
            "text": "Use sentence case, eg: \nThis is an example of sentence case.\n\n\nUse \n{@code something}\n for names of things (like \ntrue\n)\n\n\nLeave a gap after the description\n\n\nUse a full stop after every sentence\n\n\nUse the tag \n@implNotice\n to specify implementation details for the wrapper\n\n\n\n\nExample 1\n\n\n/**\n * Called when the block is right clicked.\n *\n * @param entity The entity that right clicked this object. Most likely a player.\n * @param side The side it was clicked.\n * @param hit The position it was clicked.\n * @return {@code true} if the right click action does something.\n */\npublic boolean onRightClick(Entity entity, int side, Vector3d hit) {\n    return false;\n}\n\n\n\n\n\n\nFor \n{@link}\n tags, use the full location.\n\n\n\n\nExample 2\n\n\n/**\n * Called to get the BlockFactory that refers to this Block class.\n *\n * @return The {@link nova.core.block.BlockFactory} that refers to this Block class.\n */\npublic final BlockFactory getFactory() {\n    return Game.instance.get().blockManager.getBlockFactory(this.getID()).get();\n}", 
            "title": "JavaDoc Style"
        }
    ]
}