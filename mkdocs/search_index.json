{
    "docs": [
        {
            "location": "/", 
            "text": "NOVA API\n\n\nWelcome to the documentation for the NOVA project. NOVA stands for \nN\neatly \nO\nrganized \nV\noxel \nA\nPI\n and is a project to create a total abstraction layer for creating addons to Voxel games such as \nMinecraft\n and \nTerasology\n.\n\n\nMore about NOVA\n\n\nNOVA provides modders with the ability to write mods for any game or mod loader that has a NOVA-compatible wrapper for it - which will at first include Minecraft Forge for 1.7.10 and 1.8, but developers are free to write wrappers for any other mod loader or minecraft-like game. The goal of NOVA is to provide modders both with an API that is easy to understand and learn while giving them confidence that their work can be used in many different environments without a painful update process.\n\n\nMods written using the NOVA library can be run on Forge, or can be run on top of any other mod loader or minecraft-like game for which a NOVA wrapper is available. This means that mods do not have to update when Minecraft updates. Also, it makes us relatively independent from Minecraft (or any of its mod loaders, for that matter), providing modders with the confidence that their mod will be usable even if major issues arise in Minecraft world.\n\n\nAside from the Modding API, we also hope to provide a peaceful modding environment that is open for everyone no matter their skills and experience.\n\n\nMinecraft modding is supposed to be fun \n for everyone!\n\n\nWhat\ns an abstraction layer?\n\n\nEvery version of Minecraft is built slightly differently and so is every Minecraft alternative. As a result, every time Minecraft updates, every mod written for it has to be updated to keep pace with the internal changes - there is no stable API. Even different mod loaders can add their own functionality and their own APIs to its users.\n\n\nEven though the code itself is different between each, the concepts are generally very similar. Every Minecraft-like game has a concept of blocks, items, entities, worlds, \n and instead of having modders depend on how exactly they are implemented in each game and version, we can instead expose classes and functions that expose the concepts shared by them using a stable and well-thought out API.\n\n\nBy focusing on this common API, we can make it easy to use. Additionally, by making use of Java 8 (which will be a requirement for running any NOVA wrapper) we can provide the latest language features to all modders - resulting in a cleaner API and cleaner code.\n\n\nWhat inspired you to create this?\n\n\nBesides the difficulties with porting Minecraft mods from one version to another, we have recently also seen the disappearance of a major modding API (Bukkit). When Microsoft bought Minecraft, we were not sure what their plans are, and so far, a clear statement has been absent. Modders, however, don\nt like to mod not being sure if the mod can be used in future.\n\n\nAlthough we cannot control the future of Minecraft, we can create a common API, abstract all necessary concepts with this abstraction layer, and have modders work on that. No matter what explodes in Minecraft world, we can always write a wrapper for a different modding library or any game that would contain the necessary features. The API is licensed as LGPLv3 and can be used by anyone without any legal worries, ever. And we as developers intend to communicate openly with the modding community to make sure that modders have the functionality they need.", 
            "title": "Home"
        }, 
        {
            "location": "/#nova-api", 
            "text": "Welcome to the documentation for the NOVA project. NOVA stands for  N eatly  O rganized  V oxel  A PI  and is a project to create a total abstraction layer for creating addons to Voxel games such as  Minecraft  and  Terasology .", 
            "title": "NOVA API"
        }, 
        {
            "location": "/#more-about-nova", 
            "text": "NOVA provides modders with the ability to write mods for any game or mod loader that has a NOVA-compatible wrapper for it - which will at first include Minecraft Forge for 1.7.10 and 1.8, but developers are free to write wrappers for any other mod loader or minecraft-like game. The goal of NOVA is to provide modders both with an API that is easy to understand and learn while giving them confidence that their work can be used in many different environments without a painful update process.  Mods written using the NOVA library can be run on Forge, or can be run on top of any other mod loader or minecraft-like game for which a NOVA wrapper is available. This means that mods do not have to update when Minecraft updates. Also, it makes us relatively independent from Minecraft (or any of its mod loaders, for that matter), providing modders with the confidence that their mod will be usable even if major issues arise in Minecraft world.  Aside from the Modding API, we also hope to provide a peaceful modding environment that is open for everyone no matter their skills and experience.  Minecraft modding is supposed to be fun   for everyone!", 
            "title": "More about NOVA"
        }, 
        {
            "location": "/#whats-an-abstraction-layer", 
            "text": "Every version of Minecraft is built slightly differently and so is every Minecraft alternative. As a result, every time Minecraft updates, every mod written for it has to be updated to keep pace with the internal changes - there is no stable API. Even different mod loaders can add their own functionality and their own APIs to its users.  Even though the code itself is different between each, the concepts are generally very similar. Every Minecraft-like game has a concept of blocks, items, entities, worlds,   and instead of having modders depend on how exactly they are implemented in each game and version, we can instead expose classes and functions that expose the concepts shared by them using a stable and well-thought out API.  By focusing on this common API, we can make it easy to use. Additionally, by making use of Java 8 (which will be a requirement for running any NOVA wrapper) we can provide the latest language features to all modders - resulting in a cleaner API and cleaner code.", 
            "title": "What's an abstraction layer?"
        }, 
        {
            "location": "/#what-inspired-you-to-create-this", 
            "text": "Besides the difficulties with porting Minecraft mods from one version to another, we have recently also seen the disappearance of a major modding API (Bukkit). When Microsoft bought Minecraft, we were not sure what their plans are, and so far, a clear statement has been absent. Modders, however, don t like to mod not being sure if the mod can be used in future.  Although we cannot control the future of Minecraft, we can create a common API, abstract all necessary concepts with this abstraction layer, and have modders work on that. No matter what explodes in Minecraft world, we can always write a wrapper for a different modding library or any game that would contain the necessary features. The API is licensed as LGPLv3 and can be used by anyone without any legal worries, ever. And we as developers intend to communicate openly with the modding community to make sure that modders have the functionality they need.", 
            "title": "What inspired you to create this?"
        }, 
        {
            "location": "/Mod Development/Getting Started/", 
            "text": "Mod Loading\n\n\nA mod class is the main loading class of a mod. It is annotated with @NovaMod annotation.\n\n\nA mod class may implement the interface Loadable. Once implemented, it can override the default methods \npreInit\n, \ninit\n and \npostInit\n which will be called at that sequence when the game is initialized. Most content in NOVA must be registered during the preInit phase.\n\n\n@NovaMod(id = NovaBlock.id, name = \nNova Example Block\n, version = \n0.0.1\n, novaVersion = \n0.0.1\n)\npublic class NovaBlock implements Loadable {\n\n    public static final String id = \nnovablock\n;\n\n    public static BlockFactory blockStateful;\n    public static BlockFactory blockStateless;\n\n    public final BlockManager blockManager;\n\n    public NovaBlock(BlockManager blockManager) {\n        this.blockManager = blockManager;\n    }\n\n    @Override\n    public void preInit() {\n        blockStateful = blockManager.register(BlockStateful.class);\n        blockStateless = blockManager.register(BlockStateless.class);\n    }\n}\n\n\n\n\nAll NOVA mods will need to use dependency injection. It is a clean way to inject different managers that you need into your mod class. The example above shows BlockManager being injected to the main mod class through the constructor. By specifying the \nBlockManager\n parameter in the constructor, NOVA will automatically resolve your dependencies and supply your mod with an instance of BlockManager upon construction.", 
            "title": "Getting started"
        }, 
        {
            "location": "/Mod Development/Getting Started/#mod-loading", 
            "text": "A mod class is the main loading class of a mod. It is annotated with @NovaMod annotation.  A mod class may implement the interface Loadable. Once implemented, it can override the default methods  preInit ,  init  and  postInit  which will be called at that sequence when the game is initialized. Most content in NOVA must be registered during the preInit phase.  @NovaMod(id = NovaBlock.id, name =  Nova Example Block , version =  0.0.1 , novaVersion =  0.0.1 )\npublic class NovaBlock implements Loadable {\n\n    public static final String id =  novablock ;\n\n    public static BlockFactory blockStateful;\n    public static BlockFactory blockStateless;\n\n    public final BlockManager blockManager;\n\n    public NovaBlock(BlockManager blockManager) {\n        this.blockManager = blockManager;\n    }\n\n    @Override\n    public void preInit() {\n        blockStateful = blockManager.register(BlockStateful.class);\n        blockStateless = blockManager.register(BlockStateless.class);\n    }\n}  All NOVA mods will need to use dependency injection. It is a clean way to inject different managers that you need into your mod class. The example above shows BlockManager being injected to the main mod class through the constructor. By specifying the  BlockManager  parameter in the constructor, NOVA will automatically resolve your dependencies and supply your mod with an instance of BlockManager upon construction.", 
            "title": "Mod Loading"
        }, 
        {
            "location": "/Mod Development/Blocks/", 
            "text": "Blocks\n\n\nBlocks are the basic building ingredient and its existence is impertive in any voxel game. To create a block, you must register it with the BlockManager in your mod\ns preInit() stage.\n\n\nblockStateless = blockManager.register(BlockStateless.class);\n\n\n\n\nThe code above registers a block class called \nBlockStateless\n. \nBlockStateless\n extends Block. The following is BlockStateless\ns code.\n\n\npublic class BlockStateless extends Block implements Syncable {\n\n    public BlockStateless() {\n        add(new StaticBlockRenderer(this)).setTexture(NovaBlock.steelTexture);\n\n        add(new Collider());\n\n        add(new ItemRenderer(this));\n\n        add(new Category(\nbuildingBlocks\n));\n        events.on(RightClickEvent.class).bind(this::onRightClick);\n    }\n\n    public void onRightClick(RightClickEvent evt) {\n        System.out.println(\nSending Packet: 1234\n);\n        NovaBlock.networkManager.sync(this);\n    }\n\n    @Override\n    public String getID() {\n        return \nsimple\n;\n    }\n}\n\n\n\n\nSee \nhere\n for a live example.\n\n\nComponents\n\n\nThere are some components you will probably always want to implement in your blocks, none of them are required and can be left out or replaced with your own versions of it.\n\n\nCollider\n\n\nThis component determines a few properties of your block, namely if it is a cube, opaque, what it\ns bounding and selection boxes are. It also has an eventbus for collision events\n\n\nCategory\n\n\nThis is the category(creative tab in minecraft) where this block belongs to\n\n\nItemRenderer\n\n\nThis handles the rendering of the block in your inventory and hand\n\n\nBlockrenderer\n\n\nIn this case the StaticBlockRenderer is used but there a few others you can use as well, this is responsible for rendering the block in the world. You should bind a function to get provide textures as shown in the example above or pass it a function to if different sides use different textures (shown in the advanced example below)\n\n\nThe StaticBlockRenderer only renders when the block receives an update.\n\n\nSpecial Components\n\n\nNOVA is ment to be modular and allows you to make your own components to add but it\ns also \nBatteries included\n. Here are some interfaces that NOVA provides you might find usefull\n\n\nOrientation\n\n\nOrientation allows your block to be rotated and face towards a specific side, this way it can have a front, back and sides.\n\n\nIf you just add this component to the components not much will heapen. The best thing to do is save this in a variable and annotate it with the @Sync and @Store annotations. The @Sync will sync between client and server (for that you should also have the block sync when it is placed down, see networking on how to do that)\nThe @Store will save and load the orientation so the data is not lost when the world is reloaded\n\n\nSpecial Interfaces\n\n\nSyncable\n\n\nYou may have noticed that BlockStateless implements Syncable. This interface allows the block to handle packets easily. By implementing Syncable, the block is capable of reading and writing packets between server and client. You can override the default methods \nread(Packet packet)\n and \nwrite(Packet packet)\n as shown in the example to read and write custom packets. Any variable annotated by \n@Sync\n will be synced between server and client. \n\n\nStateful\n\n\nBy default, blocks will be stateless. This means that blocks will be unable to retain their variables and state. Stateless blocks are more efficient and are appropriate for blocks that are abundant and have no internal logic (e.g: Decoration blocks, ores and resources). However, more complex blocks will need to implement \nStateful\n interface, which allows it to store its state in the world.\n\n\nStorable\n\n\nStorable allows a block to store its variables when a game saves. By implementing \nStorable\n, the block will be able to override \nsave\n and \nload\n methods. Any variable that is annotated by \n@Store\n will have their values be automatically stored. However, not all variables can be properly stored.\n\n\nRendering\n\n\nFor rendering you can use the StaticBlockRenderer shown above, make your own or use these\n\n\nRotatedRenderer\n\n\nThis is for use in combination with the Orientation component, it rotates the rendering of the block to match the rotation stored in the Orientation object. If you use this you should also use a function to give multiple textures as there is no point in rotated rendering if the block has the same texture on all sides\n\n\nAdvanced Example\n\n\nThis is an example of a block that combines most of the things listed above, it has a collider, is rotatable (and rendered as such) and print it\ns orientation to the console when rightclicked\n\n\npublic class BasicDuster extends Block implements Stateful, Storable, Syncable {\n    @Sync\n    @Store\n    private Component orientation = new Orientation(this).hookBasedOnHitSide();\n\n    public BasicDuster() {\n        add(new Collider());\n        add(orientation);\n        add(new RotatedRenderer(this).setTexture(this::getTexture));\n        add(new ItemRenderer(this));\n        add(new Category(\nbuildingBlocks\n));\n        events.on(RightClickEvent.class).bind(this::click);\n        orientation.events.on(Block.PlaceEvent.class).bind((e) -\n YourMod.networkManager.sync(this));\n    }\n\n    public Optional\nTexture\n getTexture(Direction dir) {\n        Optional\nTexture\n texture = Optional.empty();\n        switch (dir) {\n            case NORTH: texture = Optional.of(Textures.dusterFront); break;\n            case EAST:\n            case WEST: texture = Optional.of(Textures.dusterSides); break;\n            case SOUTH: texture = Optional.of(Textures.dusterBack); break;\n            case UP: texture = Optional.of(Textures.dusterTop); break;\n            case DOWN: texture = Optional.of(Textures.dusterBottom); break;\n        }\n        return texture;\n    }\n\n    @Override\n    public void read(Packet packet) {\n        Syncable.super.read(packet);\n        world().markStaticRender(position());\n    }\n\n    public void click(RightClickEvent event) {\n        if (Game.network().isServer()) {\n            System.out.println(get(Orientation.class).orientation());\n        }\n    }\n\n    @Override\n    public String getID() {\n        return \nbasicDuster\n;\n    }\n}", 
            "title": "Blocks"
        }, 
        {
            "location": "/Mod Development/Blocks/#blocks", 
            "text": "Blocks are the basic building ingredient and its existence is impertive in any voxel game. To create a block, you must register it with the BlockManager in your mod s preInit() stage.  blockStateless = blockManager.register(BlockStateless.class);  The code above registers a block class called  BlockStateless .  BlockStateless  extends Block. The following is BlockStateless s code.  public class BlockStateless extends Block implements Syncable {\n\n    public BlockStateless() {\n        add(new StaticBlockRenderer(this)).setTexture(NovaBlock.steelTexture);\n\n        add(new Collider());\n\n        add(new ItemRenderer(this));\n\n        add(new Category( buildingBlocks ));\n        events.on(RightClickEvent.class).bind(this::onRightClick);\n    }\n\n    public void onRightClick(RightClickEvent evt) {\n        System.out.println( Sending Packet: 1234 );\n        NovaBlock.networkManager.sync(this);\n    }\n\n    @Override\n    public String getID() {\n        return  simple ;\n    }\n}  See  here  for a live example.", 
            "title": "Blocks"
        }, 
        {
            "location": "/Mod Development/Blocks/#components", 
            "text": "There are some components you will probably always want to implement in your blocks, none of them are required and can be left out or replaced with your own versions of it.  Collider  This component determines a few properties of your block, namely if it is a cube, opaque, what it s bounding and selection boxes are. It also has an eventbus for collision events  Category  This is the category(creative tab in minecraft) where this block belongs to  ItemRenderer  This handles the rendering of the block in your inventory and hand  Blockrenderer  In this case the StaticBlockRenderer is used but there a few others you can use as well, this is responsible for rendering the block in the world. You should bind a function to get provide textures as shown in the example above or pass it a function to if different sides use different textures (shown in the advanced example below)  The StaticBlockRenderer only renders when the block receives an update.", 
            "title": "Components"
        }, 
        {
            "location": "/Mod Development/Blocks/#special-components", 
            "text": "NOVA is ment to be modular and allows you to make your own components to add but it s also  Batteries included . Here are some interfaces that NOVA provides you might find usefull  Orientation  Orientation allows your block to be rotated and face towards a specific side, this way it can have a front, back and sides.  If you just add this component to the components not much will heapen. The best thing to do is save this in a variable and annotate it with the @Sync and @Store annotations. The @Sync will sync between client and server (for that you should also have the block sync when it is placed down, see networking on how to do that)\nThe @Store will save and load the orientation so the data is not lost when the world is reloaded", 
            "title": "Special Components"
        }, 
        {
            "location": "/Mod Development/Blocks/#special-interfaces", 
            "text": "Syncable  You may have noticed that BlockStateless implements Syncable. This interface allows the block to handle packets easily. By implementing Syncable, the block is capable of reading and writing packets between server and client. You can override the default methods  read(Packet packet)  and  write(Packet packet)  as shown in the example to read and write custom packets. Any variable annotated by  @Sync  will be synced between server and client.   Stateful  By default, blocks will be stateless. This means that blocks will be unable to retain their variables and state. Stateless blocks are more efficient and are appropriate for blocks that are abundant and have no internal logic (e.g: Decoration blocks, ores and resources). However, more complex blocks will need to implement  Stateful  interface, which allows it to store its state in the world.  Storable  Storable allows a block to store its variables when a game saves. By implementing  Storable , the block will be able to override  save  and  load  methods. Any variable that is annotated by  @Store  will have their values be automatically stored. However, not all variables can be properly stored.", 
            "title": "Special Interfaces"
        }, 
        {
            "location": "/Mod Development/Blocks/#rendering", 
            "text": "For rendering you can use the StaticBlockRenderer shown above, make your own or use these  RotatedRenderer  This is for use in combination with the Orientation component, it rotates the rendering of the block to match the rotation stored in the Orientation object. If you use this you should also use a function to give multiple textures as there is no point in rotated rendering if the block has the same texture on all sides", 
            "title": "Rendering"
        }, 
        {
            "location": "/Mod Development/Blocks/#advanced-example", 
            "text": "This is an example of a block that combines most of the things listed above, it has a collider, is rotatable (and rendered as such) and print it s orientation to the console when rightclicked  public class BasicDuster extends Block implements Stateful, Storable, Syncable {\n    @Sync\n    @Store\n    private Component orientation = new Orientation(this).hookBasedOnHitSide();\n\n    public BasicDuster() {\n        add(new Collider());\n        add(orientation);\n        add(new RotatedRenderer(this).setTexture(this::getTexture));\n        add(new ItemRenderer(this));\n        add(new Category( buildingBlocks ));\n        events.on(RightClickEvent.class).bind(this::click);\n        orientation.events.on(Block.PlaceEvent.class).bind((e) -  YourMod.networkManager.sync(this));\n    }\n\n    public Optional Texture  getTexture(Direction dir) {\n        Optional Texture  texture = Optional.empty();\n        switch (dir) {\n            case NORTH: texture = Optional.of(Textures.dusterFront); break;\n            case EAST:\n            case WEST: texture = Optional.of(Textures.dusterSides); break;\n            case SOUTH: texture = Optional.of(Textures.dusterBack); break;\n            case UP: texture = Optional.of(Textures.dusterTop); break;\n            case DOWN: texture = Optional.of(Textures.dusterBottom); break;\n        }\n        return texture;\n    }\n\n    @Override\n    public void read(Packet packet) {\n        Syncable.super.read(packet);\n        world().markStaticRender(position());\n    }\n\n    public void click(RightClickEvent event) {\n        if (Game.network().isServer()) {\n            System.out.println(get(Orientation.class).orientation());\n        }\n    }\n\n    @Override\n    public String getID() {\n        return  basicDuster ;\n    }\n}", 
            "title": "Advanced Example"
        }, 
        {
            "location": "/Mod Development/Events/", 
            "text": "Event Handling\n\n\nNOVA also comes with events. As a feature of Java  8 you can bind functions to events as shown below.\n\n\nevents.on(RightClickEvent.class).bind(this::onRightClick);\n\n\n\n\nTo bind a function that function needs to have the class you bind with as parm, for example:\n\n\n\npublic void onRightClick(RightClickEvent evt) {\n        System.out.println(\nSending Packet: 1234\n);\n        NovaBlock.networkManager.sync(this);\n    }\n\n\n\n\n\nBlock Events", 
            "title": "Events"
        }, 
        {
            "location": "/Mod Development/Events/#event-handling", 
            "text": "NOVA also comes with events. As a feature of Java  8 you can bind functions to events as shown below.  events.on(RightClickEvent.class).bind(this::onRightClick);  To bind a function that function needs to have the class you bind with as parm, for example:  \npublic void onRightClick(RightClickEvent evt) {\n        System.out.println( Sending Packet: 1234 );\n        NovaBlock.networkManager.sync(this);\n    }", 
            "title": "Event Handling"
        }, 
        {
            "location": "/Mod Development/Events/#block-events", 
            "text": "", 
            "title": "Block Events"
        }, 
        {
            "location": "/NOVA Development/Development Workspace Setup/", 
            "text": "It is suggested to keep NOVA development in it\ns own folder, an example file structure would be something like this:\n\n\nNOVA\n|-- NovaCore\n|-- NovaWrapper-MC\n`-- NovaExample\n\n\n\n\nImportant:\n\nNOVA uses Gradle for building. To help with using Gradle, NOVA uses the Gradle wrapper system so that the developer does not have to install Gradle. For that reason, if you do not have Gradle installed, instead of typing \ngradle\n type:\n\n\n\n\ngradlew\n on Windows,\n\n\n./gradlew\n on Linux or OS X.\n\n\n\n\nNOVA Core\n\n\nSetting up a NOVA Core development workspace is easy, although most contributers will need a wrapper workspace setup too.\n\n\n\n\nClone \nNOVA-Core\n and cd to that directory\n\n\nImport the project as a Gradle project in IDEA or run \ngradle eclipse\n, depending on what IDE you use.\n\n\n\n\nMinecraft Wrapper\n\n\nThe NOVA Wrapper for Minecraft can be built in much the same way as NOVA Core, but, if you plan on modifying the source, you must create an extra file.\n\n\n\n\nClone \nNOVA-Wrapper-MC\n and \nNOVA-Core\n (If you have not cloned NOVA-Core already).\n\n\nOpen your Gradle user home directory (\n~/.gradle/\n on Linux or OSX, or \nC:/Users/[user_name]/.gradle/\n on Windows). This will not exist if you have not run Gradle before, if it does not exist, create it.\n\n\nIn your Gradle user home directory create (or edit) the file called \ngradle.properties\n.\n\n\n\n\nIn \ngradle.properties\n add the line \nnova.core.location = /path/to/NOVA-Core/\n. Make sure the path is fully qualified (i.e. starts with \nC:\\\\\n or \n/\n) and points to where you cloned NovaCore.\n\n\nPLEASE NOTE:\n Do not use quotes and you must escape backslashes in paths. Example: \nnova.core.location = C:\\\\projects\\\\NOVA\\\\NOVA-Core\n instead of \nnova.core.location = \"C:\\projects\\NOVA\\NOVA-Core\"\n.\n\n\n\n\n\n\nGo back to where you cloned NOVA-Wrapper-MC and run \ngradle setupDecompWorkspace idea genIntellijRuns\n if you use IntelliJ IDEA or \ngradle setupDecompWorkspace eclipse\n if you use Eclipse.\n\n\n\n\nAppend \n-Dfml.coreMods.load=nova.wrapper.mc1710.NovaMinecraftCore\n to the VM arguments of your run configurations.", 
            "title": "Development Workspace Setup"
        }, 
        {
            "location": "/NOVA Development/Development Workspace Setup/#nova-core", 
            "text": "Setting up a NOVA Core development workspace is easy, although most contributers will need a wrapper workspace setup too.   Clone  NOVA-Core  and cd to that directory  Import the project as a Gradle project in IDEA or run  gradle eclipse , depending on what IDE you use.", 
            "title": "NOVA Core"
        }, 
        {
            "location": "/NOVA Development/Development Workspace Setup/#minecraft-wrapper", 
            "text": "The NOVA Wrapper for Minecraft can be built in much the same way as NOVA Core, but, if you plan on modifying the source, you must create an extra file.   Clone  NOVA-Wrapper-MC  and  NOVA-Core  (If you have not cloned NOVA-Core already).  Open your Gradle user home directory ( ~/.gradle/  on Linux or OSX, or  C:/Users/[user_name]/.gradle/  on Windows). This will not exist if you have not run Gradle before, if it does not exist, create it.  In your Gradle user home directory create (or edit) the file called  gradle.properties .   In  gradle.properties  add the line  nova.core.location = /path/to/NOVA-Core/ . Make sure the path is fully qualified (i.e. starts with  C:\\\\  or  / ) and points to where you cloned NovaCore.  PLEASE NOTE:  Do not use quotes and you must escape backslashes in paths. Example:  nova.core.location = C:\\\\projects\\\\NOVA\\\\NOVA-Core  instead of  nova.core.location = \"C:\\projects\\NOVA\\NOVA-Core\" .    Go back to where you cloned NOVA-Wrapper-MC and run  gradle setupDecompWorkspace idea genIntellijRuns  if you use IntelliJ IDEA or  gradle setupDecompWorkspace eclipse  if you use Eclipse.   Append  -Dfml.coreMods.load=nova.wrapper.mc1710.NovaMinecraftCore  to the VM arguments of your run configurations.", 
            "title": "Minecraft Wrapper"
        }, 
        {
            "location": "/NOVA Development/Formatting/", 
            "text": "IDEA\n\n\n\n\nOpen your \nIDEA\n project.\n\n\nGo to \nFile -\n Import Settings...\n.\n\n\nWhen prompted, select \nintelliJ-formatter.jar\n in the \nNOVA-Core/guidelines/\n and click \nOK\n.\n\n\nNow there might be a window showing you which settings are going to be changed. Make sure all of the boxes are checked and click \nOK\n.\n\n\nRestart \nIDEA\n if asked to.\n\n\nGo to \nFile -\n Settings... -\n Editor -\n Code Style\n, select \nNOVAFormat\n as the Scheme and click \nApply\n.\n\n\nStaying in the Settings, go to \nEditor -\n Inspections\n, select \nNOVAInspect\n as the Profile, click \nApply\n and then \nOK\n.\n\n\n\n\nEclipse\n\n\n\n\nOpen your \nEclipse\n project.\n\n\nOpen the preferences window.\n\n\nOpen the \nJava -\n Code Style -\n Formatter\n pane.\n\n\nClick \nImport...\n and when prompted, select \neclipse-formatter.xml\n in the \nNOVA-Core/guidelines/\n folder.", 
            "title": "Formatting"
        }, 
        {
            "location": "/NOVA Development/Formatting/#idea", 
            "text": "Open your  IDEA  project.  Go to  File -  Import Settings... .  When prompted, select  intelliJ-formatter.jar  in the  NOVA-Core/guidelines/  and click  OK .  Now there might be a window showing you which settings are going to be changed. Make sure all of the boxes are checked and click  OK .  Restart  IDEA  if asked to.  Go to  File -  Settings... -  Editor -  Code Style , select  NOVAFormat  as the Scheme and click  Apply .  Staying in the Settings, go to  Editor -  Inspections , select  NOVAInspect  as the Profile, click  Apply  and then  OK .", 
            "title": "IDEA"
        }, 
        {
            "location": "/NOVA Development/Formatting/#eclipse", 
            "text": "Open your  Eclipse  project.  Open the preferences window.  Open the  Java -  Code Style -  Formatter  pane.  Click  Import...  and when prompted, select  eclipse-formatter.xml  in the  NOVA-Core/guidelines/  folder.", 
            "title": "Eclipse"
        }, 
        {
            "location": "/NOVA Development/JavaDoc Style/", 
            "text": "Use sentence case, eg: \nThis is an example of sentence case.\n\n\nUse \n{@code something}\n for names of things (like \ntrue\n)\n\n\nLeave a gap after the description\n\n\nUse a full stop after every sentence\n\n\nUse the tag \n@implNotice\n to specify implementation details for the wrapper\n\n\n\n\nExample 1\n\n\n/**\n * Called when the block is right clicked.\n *\n * @param entity The entity that right clicked this object. Most likely a player.\n * @param side The side it was clicked.\n * @param hit The position it was clicked.\n * @return {@code true} if the right click action does something.\n */\npublic boolean onRightClick(Entity entity, int side, Vector3d hit) {\n    return false;\n}\n\n\n\n\n\n\nFor \n{@link}\n tags, use the full location.\n\n\n\n\nExample 2\n\n\n/**\n * Called to get the BlockFactory that refers to this Block class.\n *\n * @return The {@link nova.core.block.BlockFactory} that refers to this Block class.\n */\npublic final BlockFactory getFactory() {\n    return Game.instance.get().blockManager.getBlockFactory(this.getID()).get();\n}", 
            "title": "JavaDoc Style"
        }
    ]
}