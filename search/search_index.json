{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NOVA API Welcome to the documentation for the NOVA project. NOVA stands for N eatly O rganized V oxel A PI and is a project to create a total abstraction layer for creating addons to Voxel games such as Minecraft and Terasology . More about NOVA NOVA provides modders with the ability to write mods for any game or mod loader that has a NOVA-compatible wrapper for it - which will at first include Minecraft Forge for 1.7.10, 1.8 and 1.11, but developers are free to write wrappers for any other mod loader or minecraft-like game. The goal of NOVA is to provide modders both with an API that is easy to understand and learn while giving them confidence that their work can be used in many different environments without a painful update process. Mods written using the NOVA library can be run on Forge, or can be run on top of any other mod loader or minecraft-like game for which a NOVA wrapper is available. This means that mods do not have to update when Minecraft updates. Also, it makes us relatively independent from Minecraft (or any of its mod loaders, for that matter), providing modders with the confidence that their mod will be usable even if major issues arise in Minecraft world. Aside from the Modding API, we also hope to provide a peaceful modding environment that is open for everyone no matter their skills and experience. Minecraft modding is supposed to be fun for everyone! What s an abstraction layer? Every version of Minecraft is built slightly differently and so is every Minecraft alternative. As a result, every time Minecraft updates, every mod written for it has to be updated to keep pace with the internal changes - there is no stable API. Even different mod loaders can add their own functionality and their own APIs to its users. Even though the code itself is different between each, the concepts are generally very similar. Every Minecraft-like game has a concept of blocks, items, entities, worlds, and instead of having modders depend on how exactly they are implemented in each game and version, we can instead expose classes and functions that expose the concepts shared by them using a stable and well-thought out API. By focusing on this common API, we can make it easy to use. Additionally, by making use of Java 8 (which will be a requirement for running any NOVA wrapper) we can provide the latest language features to all modders - resulting in a cleaner API and cleaner code. What inspired you to create this? Besides the difficulties with porting Minecraft mods from one version to another, we have recently also seen the disappearance of a major modding API (Bukkit). When Microsoft bought Minecraft, we were not sure what their plans are, and so far, a clear statement has been absent. Modders, however, don t like to mod not being sure if the mod can be used in future. Although we cannot control the future of Minecraft, we can create a common API, abstract all necessary concepts with this abstraction layer, and have modders work on that. No matter what explodes in Minecraft world, we can always write a wrapper for a different modding library or any game that would contain the necessary features. The API is licensed as LGPLv3 and can be used by anyone without any legal worries, ever. And we as developers intend to communicate openly with the modding community to make sure that modders have the functionality they need.","title":"Home"},{"location":"#nova-api","text":"Welcome to the documentation for the NOVA project. NOVA stands for N eatly O rganized V oxel A PI and is a project to create a total abstraction layer for creating addons to Voxel games such as Minecraft and Terasology .","title":"NOVA API"},{"location":"#more-about-nova","text":"NOVA provides modders with the ability to write mods for any game or mod loader that has a NOVA-compatible wrapper for it - which will at first include Minecraft Forge for 1.7.10, 1.8 and 1.11, but developers are free to write wrappers for any other mod loader or minecraft-like game. The goal of NOVA is to provide modders both with an API that is easy to understand and learn while giving them confidence that their work can be used in many different environments without a painful update process. Mods written using the NOVA library can be run on Forge, or can be run on top of any other mod loader or minecraft-like game for which a NOVA wrapper is available. This means that mods do not have to update when Minecraft updates. Also, it makes us relatively independent from Minecraft (or any of its mod loaders, for that matter), providing modders with the confidence that their mod will be usable even if major issues arise in Minecraft world. Aside from the Modding API, we also hope to provide a peaceful modding environment that is open for everyone no matter their skills and experience. Minecraft modding is supposed to be fun for everyone!","title":"More about NOVA"},{"location":"#whats-an-abstraction-layer","text":"Every version of Minecraft is built slightly differently and so is every Minecraft alternative. As a result, every time Minecraft updates, every mod written for it has to be updated to keep pace with the internal changes - there is no stable API. Even different mod loaders can add their own functionality and their own APIs to its users. Even though the code itself is different between each, the concepts are generally very similar. Every Minecraft-like game has a concept of blocks, items, entities, worlds, and instead of having modders depend on how exactly they are implemented in each game and version, we can instead expose classes and functions that expose the concepts shared by them using a stable and well-thought out API. By focusing on this common API, we can make it easy to use. Additionally, by making use of Java 8 (which will be a requirement for running any NOVA wrapper) we can provide the latest language features to all modders - resulting in a cleaner API and cleaner code.","title":"What's an abstraction layer?"},{"location":"#what-inspired-you-to-create-this","text":"Besides the difficulties with porting Minecraft mods from one version to another, we have recently also seen the disappearance of a major modding API (Bukkit). When Microsoft bought Minecraft, we were not sure what their plans are, and so far, a clear statement has been absent. Modders, however, don t like to mod not being sure if the mod can be used in future. Although we cannot control the future of Minecraft, we can create a common API, abstract all necessary concepts with this abstraction layer, and have modders work on that. No matter what explodes in Minecraft world, we can always write a wrapper for a different modding library or any game that would contain the necessary features. The API is licensed as LGPLv3 and can be used by anyone without any legal worries, ever. And we as developers intend to communicate openly with the modding community to make sure that modders have the functionality they need.","title":"What inspired you to create this?"},{"location":"Mod Development/Blocks/","text":"Blocks are the basic ingredient of any voxel game, and their existence is essential. To create a block, you must register it with the BlockManager in your mod s preInit() stage. BlockFactory blockStateless = blockManager.register(MOD_ID + :simple , BlockStateless::new); The code above registers a block class called BlockStateless . BlockStateless extends Block . The following is BlockStateless s code. public class BlockStateless extends Block implements Syncable { public BlockStateless() { components.add(new StaticRenderer().onRender(new BlockRenderPipeline(this).withTexture(NovaBlock.steelTexture).build())); components.add(new Collider()); components.add(new ItemRenderer(this)); // TODO: Deprecated components.add(Category.BUILDING_BLOCKS); events.on(RightClickEvent.class).bind(this::onRightClick); } public void onRightClick(RightClickEvent evt) { System.out.println( Sending Packet: 1234 ); NovaBlock.networkManager.sync(this); } @Override public void read(Packet packet) { System.out.println( Received packet: + packet.readInt()); } @Override public void write(Packet packet) { packet.writeInt(1234); } } See here for the most up-to-date example. Components There are some components you will probably always want to implement in your blocks. However, none of them are required and can be left out or replaced with your own versions of it. Collider This component determines a few properties of your block, namely if it is a cube, opaque, what its bounding and selection boxes are. It also has an event bus for collision events. The default collider is a 1x1x1 cube. Category This is the category (equivalent to a creative tab in Minecraft) that this block belongs to. ItemRenderer This handles the rendering of the block in your inventory and hand. Renderer This is responsible for rendering the block in the world. In the example above, StaticRenderer is used but there are a few others you can use as well. Special Components NOVA is meant to be modular and allows you to make your own components to add but it s also Batteries included. Here are some components that NOVA provides you might find useful. Orientation Orientation allows your block to be rotated and face towards a specific side. Using this, your block can have a front, back and specific sides. If you just add this component to the components not much will happen. The best thing to do is save this in a variable and annotate it with the @Sync and @Store annotations. The @Sync will sync between client and server (for that you should also have the block sync when it is placed down, see networking on how to do that) The @Store will save and load the orientation so the data is not lost when the world is reloaded Special Interfaces Syncable You may have noticed that BlockStateless implements Syncable. This interface allows the block to handle packets easily. By implementing Syncable, the block can synchronize between server and client. You can override the default methods read(Packet packet) and write(Packet packet) as shown in the example to read and write custom packets upon synchronization. Any variable annotated by @Sync will be synchronized between server and client, as long as you either leave the default methods alone or call Syncable.super.read(packet); and Syncable.super.write(packet); from your read and write methods respectively. Stateful By default, blocks will be stateless. This means that blocks will be unable to retain their variables and state. Stateless blocks are more efficient and are appropriate for blocks that are abundant and have no internal logic (e.g: Decoration blocks, ores and resources). However, more complex blocks will need to implement Stateful interface, which allows it to store its state in the world. Storable Storable allows a block to store its variables when a game saves. By implementing Storable , the block will be able to use the @Store annotation on variables you want to store. Note that not all variables can be properly stored via @Store , so you may need to override save and load to store the variables in whatever way fits them. If you want to use both the annotations and read/write your own custom data, call Storable.super.read(packet); and Storable.super.write(packet); in your overridden read/write methods. Rendering To render your block you have several options: Use the StaticRenderer and the BlockRenderPipeline . Use any of the other built-in NOVA renderers Create your own block renderer BlockRenderPipeline This is used for rendering simple cubes. OrientationRenderPipeline This is for use in combination with the Orientation component, it rotates the rendering of the block to match the rotation stored in the Orientation object. If you use this you should also use a function to give multiple textures as there is no point in rotated rendering if the block has the same texture on all sides. ConnectedTextureRenderPipeline This is used for rendering blocks with textures that merge when two such blocks are adjacent to each other. Advanced Example This is an example of a block that combines most of the things listed above, it has a collider, is rotatable (and rendered as such) and print it s orientation to the console when right-clicked. BlockFactory blockStateless = blockManager.register(MOD_ID + :basic_duster , BasicDuster::new); public class BasicDuster extends Block implements Stateful, Storable, Syncable { /* * Orientation component. * hookBasedOnHitSide sets up events so the orientation is set based upon, well, hit side. * This needs to be synced to client, and stored, so @Sync and @Store are used. */ @Sync @Store private Orientation orientation = new Orientation(this).hookBasedOnHitSide(); /** * Constructor for this block. Adds components, and binds events. */ public BasicDuster() { components.add(new Collider(this)); // Collider (so the player doesn't walk through the block.) components.add(orientation); // Orientation (see above) components.add(new StaticRenderer().onRender(new BlockRenderPipeline(this).withTexture(this::getTexture) .apply(new OrientationRenderPipeline(orientation)).build())); // Version of RenderPipeline that honors Orientation. components.add(new ItemRenderer(this)); // Make the item render like the block. // TODO: Deprecated components.add(new Category( buildingBlocks )); // Put this in the Building Blocks Creative category (in MC, anyway) events.on(RightClickEvent.class).bind(this::click); // Make sure click is called when a player right-clicks this block events.on(Block.PlaceEvent.class).bind((e) - YourMod.networkManager.sync(this)); // Make sure we sync when the orientation is initially set } /** * Gets the texture for a given side. * Note that this is referred to by the code above(see add(new RotatedRenderer )), * and does not have to be specifically called getTexture . It's just convention. * @param dir The direction the side is on. * @return A texture. Or empty. (TODO: What does empty do here?) */ public Optional Texture getTexture(Direction dir) { Optional Texture texture = Optional.empty(); switch (dir) { case NORTH: texture = Optional.of(Textures.dusterFront); break; case EAST: case WEST: texture = Optional.of(Textures.dusterSides); break; case SOUTH: texture = Optional.of(Textures.dusterBack); break; case UP: texture = Optional.of(Textures.dusterTop); break; case DOWN: texture = Optional.of(Textures.dusterBottom); break; } return texture; } /** * Implements Syncable.read. * This is called when a sync packet is received, to update the block's state. * @param packet The sync packet. */ @Override public void read(Packet packet) { Syncable.super.read(packet); // Make sure @Sync annotations are processed. world().markStaticRender(position()); // Mark for static render. } /** * This is referenced above(see events.on(RightClickEvent.class) ), * and handles a right click on this block. * @param event Details of the right-click event. */ public void click(RightClickEvent event) { if (Game.network().isServer()) { // If we're on the server, then write the orientation to the console for debugging. System.out.println(get(Orientation.class).orientation()); } } }","title":"Blocks"},{"location":"Mod Development/Blocks/#components","text":"There are some components you will probably always want to implement in your blocks. However, none of them are required and can be left out or replaced with your own versions of it.","title":"Components"},{"location":"Mod Development/Blocks/#collider","text":"This component determines a few properties of your block, namely if it is a cube, opaque, what its bounding and selection boxes are. It also has an event bus for collision events. The default collider is a 1x1x1 cube.","title":"Collider"},{"location":"Mod Development/Blocks/#category","text":"This is the category (equivalent to a creative tab in Minecraft) that this block belongs to.","title":"Category"},{"location":"Mod Development/Blocks/#itemrenderer","text":"This handles the rendering of the block in your inventory and hand.","title":"ItemRenderer"},{"location":"Mod Development/Blocks/#renderer","text":"This is responsible for rendering the block in the world. In the example above, StaticRenderer is used but there are a few others you can use as well.","title":"Renderer"},{"location":"Mod Development/Blocks/#special-components","text":"NOVA is meant to be modular and allows you to make your own components to add but it s also Batteries included. Here are some components that NOVA provides you might find useful.","title":"Special Components"},{"location":"Mod Development/Blocks/#orientation","text":"Orientation allows your block to be rotated and face towards a specific side. Using this, your block can have a front, back and specific sides. If you just add this component to the components not much will happen. The best thing to do is save this in a variable and annotate it with the @Sync and @Store annotations. The @Sync will sync between client and server (for that you should also have the block sync when it is placed down, see networking on how to do that) The @Store will save and load the orientation so the data is not lost when the world is reloaded","title":"Orientation"},{"location":"Mod Development/Blocks/#special-interfaces","text":"","title":"Special Interfaces"},{"location":"Mod Development/Blocks/#syncable","text":"You may have noticed that BlockStateless implements Syncable. This interface allows the block to handle packets easily. By implementing Syncable, the block can synchronize between server and client. You can override the default methods read(Packet packet) and write(Packet packet) as shown in the example to read and write custom packets upon synchronization. Any variable annotated by @Sync will be synchronized between server and client, as long as you either leave the default methods alone or call Syncable.super.read(packet); and Syncable.super.write(packet); from your read and write methods respectively.","title":"Syncable"},{"location":"Mod Development/Blocks/#stateful","text":"By default, blocks will be stateless. This means that blocks will be unable to retain their variables and state. Stateless blocks are more efficient and are appropriate for blocks that are abundant and have no internal logic (e.g: Decoration blocks, ores and resources). However, more complex blocks will need to implement Stateful interface, which allows it to store its state in the world.","title":"Stateful"},{"location":"Mod Development/Blocks/#storable","text":"Storable allows a block to store its variables when a game saves. By implementing Storable , the block will be able to use the @Store annotation on variables you want to store. Note that not all variables can be properly stored via @Store , so you may need to override save and load to store the variables in whatever way fits them. If you want to use both the annotations and read/write your own custom data, call Storable.super.read(packet); and Storable.super.write(packet); in your overridden read/write methods.","title":"Storable"},{"location":"Mod Development/Blocks/#rendering","text":"To render your block you have several options: Use the StaticRenderer and the BlockRenderPipeline . Use any of the other built-in NOVA renderers Create your own block renderer","title":"Rendering"},{"location":"Mod Development/Blocks/#blockrenderpipeline","text":"This is used for rendering simple cubes.","title":"BlockRenderPipeline"},{"location":"Mod Development/Blocks/#orientationrenderpipeline","text":"This is for use in combination with the Orientation component, it rotates the rendering of the block to match the rotation stored in the Orientation object. If you use this you should also use a function to give multiple textures as there is no point in rotated rendering if the block has the same texture on all sides.","title":"OrientationRenderPipeline"},{"location":"Mod Development/Blocks/#connectedtexturerenderpipeline","text":"This is used for rendering blocks with textures that merge when two such blocks are adjacent to each other.","title":"ConnectedTextureRenderPipeline"},{"location":"Mod Development/Blocks/#advanced-example","text":"This is an example of a block that combines most of the things listed above, it has a collider, is rotatable (and rendered as such) and print it s orientation to the console when right-clicked. BlockFactory blockStateless = blockManager.register(MOD_ID + :basic_duster , BasicDuster::new); public class BasicDuster extends Block implements Stateful, Storable, Syncable { /* * Orientation component. * hookBasedOnHitSide sets up events so the orientation is set based upon, well, hit side. * This needs to be synced to client, and stored, so @Sync and @Store are used. */ @Sync @Store private Orientation orientation = new Orientation(this).hookBasedOnHitSide(); /** * Constructor for this block. Adds components, and binds events. */ public BasicDuster() { components.add(new Collider(this)); // Collider (so the player doesn't walk through the block.) components.add(orientation); // Orientation (see above) components.add(new StaticRenderer().onRender(new BlockRenderPipeline(this).withTexture(this::getTexture) .apply(new OrientationRenderPipeline(orientation)).build())); // Version of RenderPipeline that honors Orientation. components.add(new ItemRenderer(this)); // Make the item render like the block. // TODO: Deprecated components.add(new Category( buildingBlocks )); // Put this in the Building Blocks Creative category (in MC, anyway) events.on(RightClickEvent.class).bind(this::click); // Make sure click is called when a player right-clicks this block events.on(Block.PlaceEvent.class).bind((e) - YourMod.networkManager.sync(this)); // Make sure we sync when the orientation is initially set } /** * Gets the texture for a given side. * Note that this is referred to by the code above(see add(new RotatedRenderer )), * and does not have to be specifically called getTexture . It's just convention. * @param dir The direction the side is on. * @return A texture. Or empty. (TODO: What does empty do here?) */ public Optional Texture getTexture(Direction dir) { Optional Texture texture = Optional.empty(); switch (dir) { case NORTH: texture = Optional.of(Textures.dusterFront); break; case EAST: case WEST: texture = Optional.of(Textures.dusterSides); break; case SOUTH: texture = Optional.of(Textures.dusterBack); break; case UP: texture = Optional.of(Textures.dusterTop); break; case DOWN: texture = Optional.of(Textures.dusterBottom); break; } return texture; } /** * Implements Syncable.read. * This is called when a sync packet is received, to update the block's state. * @param packet The sync packet. */ @Override public void read(Packet packet) { Syncable.super.read(packet); // Make sure @Sync annotations are processed. world().markStaticRender(position()); // Mark for static render. } /** * This is referenced above(see events.on(RightClickEvent.class) ), * and handles a right click on this block. * @param event Details of the right-click event. */ public void click(RightClickEvent event) { if (Game.network().isServer()) { // If we're on the server, then write the orientation to the console for debugging. System.out.println(get(Orientation.class).orientation()); } } }","title":"Advanced Example"},{"location":"Mod Development/Events/","text":"Event Handling One of NOVA s core features is the large variety of events you can use. With Java 8, you can bind functions to events like so: events.on(RightClickEvent.class).bind(this::onRightClick); To bind a function that function needs to have the class you bind with as parm, for example: public void onRightClick(RightClickEvent evt) { System.out.println( Sending Packet: 1234 ); NovaBlock.networkManager.sync(this); } Available Events Block Events NeighborChangeEvent PlaceEvent RemoveEvent RightClickEvent LeftClickEvent DropEvent Item Events TooltipEvent UseEvent RightClickEvent","title":"Events"},{"location":"Mod Development/Events/#event-handling","text":"One of NOVA s core features is the large variety of events you can use. With Java 8, you can bind functions to events like so: events.on(RightClickEvent.class).bind(this::onRightClick); To bind a function that function needs to have the class you bind with as parm, for example: public void onRightClick(RightClickEvent evt) { System.out.println( Sending Packet: 1234 ); NovaBlock.networkManager.sync(this); }","title":"Event Handling"},{"location":"Mod Development/Events/#available-events","text":"","title":"Available Events"},{"location":"Mod Development/Events/#block-events","text":"NeighborChangeEvent PlaceEvent RemoveEvent RightClickEvent LeftClickEvent DropEvent","title":"Block Events"},{"location":"Mod Development/Events/#item-events","text":"TooltipEvent UseEvent RightClickEvent","title":"Item Events"},{"location":"Mod Development/Getting Started/","text":"Workspace Setup Workspace setup is done with the NOVA Gradle plugin, make sure you follow the setup docs here Mod Loading All mods have a main class that is annotated with @Mod . The @Mod annotation tells NOVA that this is a mod class that needs to be loaded. Furthermore, to actually load content in NOVA, a mod has to have GlobalEvents in the constructor and call the globalEvents.on(Manager.Init.class).bind(evt - this.register(evt.manager)); method to register content for that manager. @Mod(id = NovaBlock.MOD_ID, name = Nova Example Block , version = 0.0.1 , novaVersion = 0.1.0 ) public class NovaBlock { public static final String MOD_ID = novablock ; public static BlockFactory blockStateful; public static BlockFactory blockStateless; public final GlobalEvents globalEvents; public final BlockManager blockManager; public NovaBlock(GlobalEvents globalEvents, BlockManager blockManager) { this.blockManager = blockManager; this.globalEvents = globalEvents; this.globalEvents.on(BlockManager.Init.class).bind(evt - this.registerBlocks(evt.manager)); } public void registerBlocks(BlockManager blockManager) { blockStateful = blockManager.register(MOD_ID + :stateful , BlockStateful::new); blockStateless = blockManager.register(MOD_ID + :simple , BlockStateless::new); } } Dependency Injection All NOVA mods use dependency injection. Using dependency injection NOVA mods can automatically accept only the managers that they need. In the example above, the mod constructor only accepts a BlockManager and GlobalEvents so when the mod is constructed it will only be passed a BlockManager and GlobalEvents . If we were to change the constructor so it accepts a BlockManager , an ItemManager and GlobalEvents , the dependency injection system will pass it a BlockManager , an ItemManager and GlobalEvents when the mod is constructed. This allows the mod constructor to only accept whatever it needs and NOVA will determine what to pass it at load time. Working with third party mods When writing a NOVA mod, sometimes, you might want to extend content from another mod. This can be achieved by using the dependencies parameter of the Mod annotation. The strings in the array are formatted as other_mod_id@1.0.x , where: other_mod_id is the id of the other mod. 1.0.x is the version, where the letter x is used as a wildcard. (optional) adding f to the end of the string makes the mod required.","title":"Getting started"},{"location":"Mod Development/Getting Started/#workspace-setup","text":"Workspace setup is done with the NOVA Gradle plugin, make sure you follow the setup docs here","title":"Workspace Setup"},{"location":"Mod Development/Getting Started/#mod-loading","text":"All mods have a main class that is annotated with @Mod . The @Mod annotation tells NOVA that this is a mod class that needs to be loaded. Furthermore, to actually load content in NOVA, a mod has to have GlobalEvents in the constructor and call the globalEvents.on(Manager.Init.class).bind(evt - this.register(evt.manager)); method to register content for that manager. @Mod(id = NovaBlock.MOD_ID, name = Nova Example Block , version = 0.0.1 , novaVersion = 0.1.0 ) public class NovaBlock { public static final String MOD_ID = novablock ; public static BlockFactory blockStateful; public static BlockFactory blockStateless; public final GlobalEvents globalEvents; public final BlockManager blockManager; public NovaBlock(GlobalEvents globalEvents, BlockManager blockManager) { this.blockManager = blockManager; this.globalEvents = globalEvents; this.globalEvents.on(BlockManager.Init.class).bind(evt - this.registerBlocks(evt.manager)); } public void registerBlocks(BlockManager blockManager) { blockStateful = blockManager.register(MOD_ID + :stateful , BlockStateful::new); blockStateless = blockManager.register(MOD_ID + :simple , BlockStateless::new); } }","title":"Mod Loading"},{"location":"Mod Development/Getting Started/#dependency-injection","text":"All NOVA mods use dependency injection. Using dependency injection NOVA mods can automatically accept only the managers that they need. In the example above, the mod constructor only accepts a BlockManager and GlobalEvents so when the mod is constructed it will only be passed a BlockManager and GlobalEvents . If we were to change the constructor so it accepts a BlockManager , an ItemManager and GlobalEvents , the dependency injection system will pass it a BlockManager , an ItemManager and GlobalEvents when the mod is constructed. This allows the mod constructor to only accept whatever it needs and NOVA will determine what to pass it at load time.","title":"Dependency Injection"},{"location":"Mod Development/Getting Started/#working-with-third-party-mods","text":"When writing a NOVA mod, sometimes, you might want to extend content from another mod. This can be achieved by using the dependencies parameter of the Mod annotation. The strings in the array are formatted as other_mod_id@1.0.x , where: other_mod_id is the id of the other mod. 1.0.x is the version, where the letter x is used as a wildcard. (optional) adding f to the end of the string makes the mod required.","title":"Working with third party mods"},{"location":"Mod Development/Items/","text":"Items are the second basic ingredient of any voxel game, and their existence is almost as essential as the existence of blocks. To create an item, you must register it with the ItemManager in your mod s preInit() stage. ItemFactory itemScrewdriver = itemManager.register(MOD_ID + :testscrewdriver , ItemScrewdriver::new); The code above registers an item class called ItemScrewdriver . ItemScrewdriver extends Item . The following is ItemScrewdriver s code. public class ItemScrewdriver extends Item { public ItemScrewdriver() { components.add(Category.TOOLS); components.add(new ItemRenderer()).setTexture(NovaItem.screwTexture); // TODO: Deprecated events.on(UseEvent.class).bind(event - event.action = true); } } See here for the most up-to-date example. Components There are some components you will probably always want to implement in your items. However, none of them are required and can be left out or replaced with your own versions of it. Category This is the category (equivalent to a creative tab in Minecraft) that this item belongs to. ItemRenderer This handles the rendering of the item in your inventory and hand. Special Interfaces Syncable Syncable allows an item to handle packets easily. By implementing Syncable, the item can synchronize between server and client. You can override the default methods read(Packet packet) and write(Packet packet) as shown in the example to read and write custom packets upon synchronization. Any variable annotated by @Sync will be synchronized between server and client, as long as you either leave the default methods alone or call Syncable.super.read(packet); and Syncable.super.write(packet); from your read and write methods respectively. Storable Storable allows an item to store its variables when a game saves. By implementing Storable , the item will be able to use the @Store annotation on variables you want to store. Note that not all variables can be properly stored via @Store , so you may need to override save and load to store the variables in whatever way fits them. If you want to use both the annotations and read/write your own custom data, call Storable.super.read(packet); and Storable.super.write(packet); in your overridden read/write methods. Examples include: Electric charge of batteries, amount of fuel in a canister, etc. Rendering To render your item you have several options: Use the ItemRenderer (Deprecated) Use any of the other built-in NOVA renderers Create your own item renderer ItemRenderer This is used for rendering simple items with a single texture.","title":"Items"},{"location":"Mod Development/Items/#components","text":"There are some components you will probably always want to implement in your items. However, none of them are required and can be left out or replaced with your own versions of it.","title":"Components"},{"location":"Mod Development/Items/#category","text":"This is the category (equivalent to a creative tab in Minecraft) that this item belongs to.","title":"Category"},{"location":"Mod Development/Items/#itemrenderer","text":"This handles the rendering of the item in your inventory and hand.","title":"ItemRenderer"},{"location":"Mod Development/Items/#special-interfaces","text":"","title":"Special Interfaces"},{"location":"Mod Development/Items/#syncable","text":"Syncable allows an item to handle packets easily. By implementing Syncable, the item can synchronize between server and client. You can override the default methods read(Packet packet) and write(Packet packet) as shown in the example to read and write custom packets upon synchronization. Any variable annotated by @Sync will be synchronized between server and client, as long as you either leave the default methods alone or call Syncable.super.read(packet); and Syncable.super.write(packet); from your read and write methods respectively.","title":"Syncable"},{"location":"Mod Development/Items/#storable","text":"Storable allows an item to store its variables when a game saves. By implementing Storable , the item will be able to use the @Store annotation on variables you want to store. Note that not all variables can be properly stored via @Store , so you may need to override save and load to store the variables in whatever way fits them. If you want to use both the annotations and read/write your own custom data, call Storable.super.read(packet); and Storable.super.write(packet); in your overridden read/write methods. Examples include: Electric charge of batteries, amount of fuel in a canister, etc.","title":"Storable"},{"location":"Mod Development/Items/#rendering","text":"To render your item you have several options: Use the ItemRenderer (Deprecated) Use any of the other built-in NOVA renderers Create your own item renderer","title":"Rendering"},{"location":"Mod Development/Items/#itemrenderer_1","text":"This is used for rendering simple items with a single texture.","title":"ItemRenderer"},{"location":"Mod Development/NOVA Gradle/","text":"If you feel like tl;dring this article, skip to #getting-started . I however do not recommend this because knowing your build system will save you trouble later. If you know gradle well, you know what to skip already. NOVA Gradle is the Gradle plugin which allows you to run NOVA mods on wrappers easily during testing. Vanilla Gradle can compile and produce (non-wrapper) NOVA mods and plugins easily but it lacks an easy way to test and debug these mods ingame. NOVA Gradle handles IDE setup and game setup for you so you don t have to. Let s get started! Gradle Gradle is a tool some of you will have used when compiling Minecraft Forge mods. The Gradle DSL which Gradle uses to define configuration is written in Groovy, so you can use the awesome Groovy programming language to script your build. Despite this, Gradle is convention based and declarative. Compiling a NOVA project is as simple as: plugins { id java } repositories { mavenLocal() jcenter() maven { url http://maven.novaapi.net/ } } dependencies { compile nova.core:NOVA-Core:0.1.0-SNAPSHOT:api } This short snippet simply defines that you are using the java Gradle plugin (you want to compile java), that you want to resolve dependencies from the jcenter and NOVA repositories and that your project s compilation depends on the NOVA api, version 0.1.0-SNAPSHOT . The java plugin defines several important tasks just as compileJava jar and build . But wait you say, how do you run Gradle? Do I have to install yet another thing What a pain! The Gradle Wrapper The Gradle wrapper solves this problem by providing scripts that you place in your project directory which downloads Gradle automatically for you then invokes the downloaded Gradle version. The Gradle wrapper is included in the NOVA template project. NOVA Gradle The previous snippet allows you to build a jar which can be loaded by NOVA wrappers, but there is no easy way to debug and run this mod every time you make a change. This is where NOVA Gradle comes in. Getting started To explain to you how to use NOVA Gradle and how to set up your mod development workspace, we will use the NOVA template project from Github. The NOVA Template project can be downloaded from here and then unzipped to the place where you want to develop your mod. You will see the following files in the template: If you are tl;dring, skip everything that isn t marked Customise this until Setting up build.gradle This file is the file which describes the Gradle build process. Here is an annotated version of the default build.gradle , please use the file from NOVA-Template instead of copying this . plugins { id java //This is a java project, scala and groovy plugins also exist id nova.gradle version 0.2.6 //Use the NOVA Gradle plugin version 0.2.6 } dependencies { //Dependencies of this project compile nova(nova_version) //Depend on NOVA for compiling } nova { //This block is used for configuring the NOVA Gradle plugin wrappers { //Configures wrapper profiles /** * This profile is called 17 , you can skip the quotes if it's not numbers. * This profile for example will generate the run17Client gradle task and create an IDEA * config of the same name. * The name can be changed to your liking. */ //Wrapper profile for MC 1.7.10 17 { //The maven identifier of the wrapper this wrapper profile will use. wrapper nova.core:NOVA-Core-Wrapper-MC1.7:${nova_version} } //Wrapper profile for MC 1.8 18 { wrapper nova.core:NOVA-Core-Wrapper-MC1.8:${nova_version} } } } gradle.properties (Customise this) This file stores properties which are made available to the build process, such as version and maven group. The Maven group defines a unique identifier for your project, and should be the same as your Java package. The convention is to use your domain name backwards as the start of your package, for example net.novaapi.template if you own the domain novaapi.net . If you don t have a domain, and you are open-sourcing the mod, the common practise is to use com.github.githubusername.githubprojectname . If you aren t open sourcing or publishing the mod API, nobody really cares what package name you use # Mod version version = 0.1.0 # Maven group group = net.novaapi.template # NOVA version nova_version = 0.1.0-SNAPSHOT settings.gradle (Customise this) This file is used for setting the name of the project ( rootProject.name = \"project name\" ) and for multi-project builds. Multi-project builds are a complex topic that I will not cover in this introduction. If you wish to learn about multi-project builds, you can do so here . gradlew and gradlew.bat These scripts are the gradle wrapper scripts mentined before for running gradle. Use simply gradlew on windows and ./gradlew on linux. .gitignore This file configures files and folders ignored if you use the git revision control system. We ve included sensible defaults for you, so you don t go publishing all the wrong things. Remember, if you publish the wrong things you will make RX14 mildly depressed if he happens across your project. The gradle/ folder This is just files related to the gradle wrapper, you may occationally need to update the wrapper version in this folder, but unless instructed just ignore it. Setting up After customising the files in your template project, pop up a terminal and cd to the project directory. Idea When you are in your project directory use ./gradlew idea on linux or gradlew idea on windows to generate IDEA project files. After it has generated these files, open the .ipr IDEA Project file in IDEA. You should see some run configurations added corresponding to the wrapper profiles in the build.gradle . Eclipse If you are using eclipse instead of IDEA, you will have to run gradle eclipse and import the generated project into a new or existing workspace. No run configurations will be gerated, so you will have to use the gradle plugin for eclipse to run the wrapper gradle tasks (e.g. run17Client ). NetBeans If you are using NetBeans instead of any of the above, you will have to get the gradle plugin for NetBeans . This will allow you to open any folder containing a .gradle file as a project and run the wrapper gradle tasks (e.g. run18Client ). IDEA Bugs (on windows) The supplied javaHome seems to be invalid. I cannot find the java executable. Tried location: C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA 14.1.4\\jre\\bin\\java.exe` You will most likely experience the above (or similar) error when trying to run or debug the client. This is a bug in IDEA, and the workaround is to use 64-bit IDEA. To do this, edit your IntelliJ start menu shortcut and change the path of what it is running from \"C:\\Install Path\\bin\\idea.exe\" to \"C:\\Install Path\\bin\\idea64.exe\" like this: If the problem persists after this please ask in IRC.","title":"NOVA Gradle"},{"location":"Mod Development/NOVA Gradle/#gradle","text":"Gradle is a tool some of you will have used when compiling Minecraft Forge mods. The Gradle DSL which Gradle uses to define configuration is written in Groovy, so you can use the awesome Groovy programming language to script your build. Despite this, Gradle is convention based and declarative. Compiling a NOVA project is as simple as: plugins { id java } repositories { mavenLocal() jcenter() maven { url http://maven.novaapi.net/ } } dependencies { compile nova.core:NOVA-Core:0.1.0-SNAPSHOT:api } This short snippet simply defines that you are using the java Gradle plugin (you want to compile java), that you want to resolve dependencies from the jcenter and NOVA repositories and that your project s compilation depends on the NOVA api, version 0.1.0-SNAPSHOT . The java plugin defines several important tasks just as compileJava jar and build . But wait you say, how do you run Gradle? Do I have to install yet another thing What a pain!","title":"Gradle"},{"location":"Mod Development/NOVA Gradle/#the-gradle-wrapper","text":"The Gradle wrapper solves this problem by providing scripts that you place in your project directory which downloads Gradle automatically for you then invokes the downloaded Gradle version. The Gradle wrapper is included in the NOVA template project.","title":"The Gradle Wrapper"},{"location":"Mod Development/NOVA Gradle/#nova-gradle","text":"The previous snippet allows you to build a jar which can be loaded by NOVA wrappers, but there is no easy way to debug and run this mod every time you make a change. This is where NOVA Gradle comes in.","title":"NOVA Gradle"},{"location":"Mod Development/NOVA Gradle/#getting-started","text":"To explain to you how to use NOVA Gradle and how to set up your mod development workspace, we will use the NOVA template project from Github. The NOVA Template project can be downloaded from here and then unzipped to the place where you want to develop your mod. You will see the following files in the template: If you are tl;dring, skip everything that isn t marked Customise this until Setting up","title":"Getting started"},{"location":"Mod Development/NOVA Gradle/#buildgradle","text":"This file is the file which describes the Gradle build process. Here is an annotated version of the default build.gradle , please use the file from NOVA-Template instead of copying this . plugins { id java //This is a java project, scala and groovy plugins also exist id nova.gradle version 0.2.6 //Use the NOVA Gradle plugin version 0.2.6 } dependencies { //Dependencies of this project compile nova(nova_version) //Depend on NOVA for compiling } nova { //This block is used for configuring the NOVA Gradle plugin wrappers { //Configures wrapper profiles /** * This profile is called 17 , you can skip the quotes if it's not numbers. * This profile for example will generate the run17Client gradle task and create an IDEA * config of the same name. * The name can be changed to your liking. */ //Wrapper profile for MC 1.7.10 17 { //The maven identifier of the wrapper this wrapper profile will use. wrapper nova.core:NOVA-Core-Wrapper-MC1.7:${nova_version} } //Wrapper profile for MC 1.8 18 { wrapper nova.core:NOVA-Core-Wrapper-MC1.8:${nova_version} } } }","title":"build.gradle"},{"location":"Mod Development/NOVA Gradle/#gradleproperties-customise-this","text":"This file stores properties which are made available to the build process, such as version and maven group. The Maven group defines a unique identifier for your project, and should be the same as your Java package. The convention is to use your domain name backwards as the start of your package, for example net.novaapi.template if you own the domain novaapi.net . If you don t have a domain, and you are open-sourcing the mod, the common practise is to use com.github.githubusername.githubprojectname . If you aren t open sourcing or publishing the mod API, nobody really cares what package name you use # Mod version version = 0.1.0 # Maven group group = net.novaapi.template # NOVA version nova_version = 0.1.0-SNAPSHOT","title":"gradle.properties (Customise this)"},{"location":"Mod Development/NOVA Gradle/#settingsgradle-customise-this","text":"This file is used for setting the name of the project ( rootProject.name = \"project name\" ) and for multi-project builds. Multi-project builds are a complex topic that I will not cover in this introduction. If you wish to learn about multi-project builds, you can do so here .","title":"settings.gradle (Customise this)"},{"location":"Mod Development/NOVA Gradle/#gradlew-and-gradlewbat","text":"These scripts are the gradle wrapper scripts mentined before for running gradle. Use simply gradlew on windows and ./gradlew on linux.","title":"gradlew and gradlew.bat"},{"location":"Mod Development/NOVA Gradle/#gitignore","text":"This file configures files and folders ignored if you use the git revision control system. We ve included sensible defaults for you, so you don t go publishing all the wrong things. Remember, if you publish the wrong things you will make RX14 mildly depressed if he happens across your project.","title":".gitignore"},{"location":"Mod Development/NOVA Gradle/#the-gradle-folder","text":"This is just files related to the gradle wrapper, you may occationally need to update the wrapper version in this folder, but unless instructed just ignore it.","title":"The gradle/ folder"},{"location":"Mod Development/NOVA Gradle/#setting-up","text":"After customising the files in your template project, pop up a terminal and cd to the project directory.","title":"Setting up"},{"location":"Mod Development/NOVA Gradle/#idea","text":"When you are in your project directory use ./gradlew idea on linux or gradlew idea on windows to generate IDEA project files. After it has generated these files, open the .ipr IDEA Project file in IDEA. You should see some run configurations added corresponding to the wrapper profiles in the build.gradle .","title":"Idea"},{"location":"Mod Development/NOVA Gradle/#eclipse","text":"If you are using eclipse instead of IDEA, you will have to run gradle eclipse and import the generated project into a new or existing workspace. No run configurations will be gerated, so you will have to use the gradle plugin for eclipse to run the wrapper gradle tasks (e.g. run17Client ).","title":"Eclipse"},{"location":"Mod Development/NOVA Gradle/#netbeans","text":"If you are using NetBeans instead of any of the above, you will have to get the gradle plugin for NetBeans . This will allow you to open any folder containing a .gradle file as a project and run the wrapper gradle tasks (e.g. run18Client ).","title":"NetBeans"},{"location":"Mod Development/NOVA Gradle/#idea-bugs-on-windows","text":"The supplied javaHome seems to be invalid. I cannot find the java executable. Tried location: C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA 14.1.4\\jre\\bin\\java.exe` You will most likely experience the above (or similar) error when trying to run or debug the client. This is a bug in IDEA, and the workaround is to use 64-bit IDEA. To do this, edit your IntelliJ start menu shortcut and change the path of what it is running from \"C:\\Install Path\\bin\\idea.exe\" to \"C:\\Install Path\\bin\\idea64.exe\" like this: If the problem persists after this please ask in IRC.","title":"IDEA Bugs (on windows)"},{"location":"NOVA Development/Development Workspace Setup/","text":"It is suggested to keep NOVA development in it s own folder, an example file structure would be something like this: NOVA |-- core |-- gui ... Important: NOVA uses Gradle for building. To help with using Gradle, NOVA uses the Gradle wrapper system so that the developer does not have to install Gradle. For that reason, if you do not have Gradle installed, instead of typing gradle type: gradlew on Windows, ./gradlew on Linux or OS X. NOVA Core Setting up a NOVA Core development workspace is easy, here s how you do it: Clone NOVA-Core . Run gradle setupDecompWorkspace idea if you use IntelliJ IDEA or gradle setupDecompWorkspace eclipse if you use Eclipse. Append -Dfml.coreMods.load=nova.core.wrapper.mc.forge.v1_11.NovaMinecraftCore for MC v1.11, -Dfml.coreMods.load=nova.core.wrapper.mc.forge.v18.NovaMinecraftCore for MC v1.8 or -Dfml.coreMods.load=nova.core.wrapper.mc.forge.v17.NovaMinecraftCore for MC v1.7 to the VM arguments of your run configurations.","title":"Development Workspace Setup"},{"location":"NOVA Development/Development Workspace Setup/#nova-core","text":"Setting up a NOVA Core development workspace is easy, here s how you do it: Clone NOVA-Core . Run gradle setupDecompWorkspace idea if you use IntelliJ IDEA or gradle setupDecompWorkspace eclipse if you use Eclipse. Append -Dfml.coreMods.load=nova.core.wrapper.mc.forge.v1_11.NovaMinecraftCore for MC v1.11, -Dfml.coreMods.load=nova.core.wrapper.mc.forge.v18.NovaMinecraftCore for MC v1.8 or -Dfml.coreMods.load=nova.core.wrapper.mc.forge.v17.NovaMinecraftCore for MC v1.7 to the VM arguments of your run configurations.","title":"NOVA Core"},{"location":"NOVA Development/Formatting/","text":"IDEA Open your IDEA project. Go to File - Import Settings... . When prompted, select intelliJ-formatter.jar in the NOVA-Core/guidelines/ and click OK . Now there might be a window showing you which settings are going to be changed. Make sure all of the boxes are checked and click OK . Restart IDEA if asked to. Go to File - Settings... - Editor - Code Style , select NOVAFormat as the Scheme and click Apply . Staying in the Settings, go to Editor - Inspections , select NOVAInspect as the Profile, click Apply and then OK . Eclipse Open your Eclipse project. Open the preferences window. Open the Java - Code Style - Formatter pane. Click Import... and when prompted, select eclipse-formatter.xml in the NOVA-Core/guidelines/ folder.","title":"Formatting"},{"location":"NOVA Development/Formatting/#idea","text":"Open your IDEA project. Go to File - Import Settings... . When prompted, select intelliJ-formatter.jar in the NOVA-Core/guidelines/ and click OK . Now there might be a window showing you which settings are going to be changed. Make sure all of the boxes are checked and click OK . Restart IDEA if asked to. Go to File - Settings... - Editor - Code Style , select NOVAFormat as the Scheme and click Apply . Staying in the Settings, go to Editor - Inspections , select NOVAInspect as the Profile, click Apply and then OK .","title":"IDEA"},{"location":"NOVA Development/Formatting/#eclipse","text":"Open your Eclipse project. Open the preferences window. Open the Java - Code Style - Formatter pane. Click Import... and when prompted, select eclipse-formatter.xml in the NOVA-Core/guidelines/ folder.","title":"Eclipse"},{"location":"NOVA Development/JavaDoc Style/","text":"Use sentence case, eg: This is an example of sentence case. Use {@code something} for names of things (like true ) Leave a gap after the description Use a full stop after every sentence Use the tag @implNotice to specify implementation details for the wrapper Example 1 /** * Called when the block is right clicked. * * @param entity The entity that right clicked this object. Most likely a player. * @param side The side it was clicked. * @param hit The position it was clicked. * @return {@code true} if the right click action does something. */ public boolean onRightClick(Entity entity, int side, Vector3d hit) { return false; } For {@link} tags, use the full location. Example 2 /** * Called to get the BlockFactory that refers to this Block class. * * @return The {@link nova.core.block.BlockFactory} that refers to this Block class. */ public final BlockFactory getFactory() { return (BlockFactory) components.get(FactoryProvider.class).factory; }","title":"JavaDoc Style"},{"location":"NOVA Development/JavaDoc Style/#example-1","text":"/** * Called when the block is right clicked. * * @param entity The entity that right clicked this object. Most likely a player. * @param side The side it was clicked. * @param hit The position it was clicked. * @return {@code true} if the right click action does something. */ public boolean onRightClick(Entity entity, int side, Vector3d hit) { return false; } For {@link} tags, use the full location.","title":"Example 1"},{"location":"NOVA Development/JavaDoc Style/#example-2","text":"/** * Called to get the BlockFactory that refers to this Block class. * * @return The {@link nova.core.block.BlockFactory} that refers to this Block class. */ public final BlockFactory getFactory() { return (BlockFactory) components.get(FactoryProvider.class).factory; }","title":"Example 2"}]}